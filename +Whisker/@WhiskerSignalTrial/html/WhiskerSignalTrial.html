
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>WhiskerSignalTrial</title><meta name="generator" content="MATLAB 7.14"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2013-07-18"><meta name="DC.source" content="WhiskerSignalTrial.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, tt, code { font-size:12px; }
pre { margin:0px 0px 20px; }
pre.error { color:red; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }

  </style></head><body><div class="content"><pre class="codeinput"><span class="keyword">classdef</span> WhiskerSignalTrial &lt; handle
    <span class="comment">%</span>
    <span class="comment">%</span>
    <span class="comment">%   WhiskerSignalTrial &lt; handle</span>
    <span class="comment">%</span>
    <span class="comment">% A class that deals with polynomial fits to tracked whisker (x,y) data.</span>
    <span class="comment">% The original (x,y) data are not preserved in WhiskerSignalTrial.</span>
    <span class="comment">%</span>
    <span class="comment">% DHO, 8/08.</span>
    <span class="comment">%</span>
    <span class="comment">%</span>
    <span class="keyword">properties</span>
        trialNum = [];
        trialType = NaN;
        whiskerNames = {};  <span class="comment">% whiskerNames and trajectoryIDs must be of same length</span>
        trajectoryIDs = []; <span class="comment">% with matching elements.</span>
        framePeriodInSec = 0.002;
        mouseName = <span class="string">''</span>;
        sessionName = <span class="string">''</span>;
        trackerFileName = <span class="string">''</span>;

        <span class="comment">% polyFits: Inherited from WhiskerTrial.</span>
        <span class="comment">% Cell array of length length(trajectoryIDs), of format:</span>
        <span class="comment">% {{XPolyCoeffs_tid0, YPolyCoeffs_tid0},...,{XPolyCoeffs_tidN, YPolyCoeffs_tidN}};</span>
        polyFits = {};

        polyFitsROI = {}; <span class="comment">% polyFitsROI: Inherited from WhiskerTrial.</span>
                          <span class="comment">% Same format as polyFits but polynomials are fitted only to a</span>
                          <span class="comment">% constant region of arc length, and in addition to x and y coefficients</span>
                          <span class="comment">% there is stored the "q" values, i.e. the points along the normalized full</span>
                          <span class="comment">% whisker ([0,1]) that the ROI fitting begins,as well as the two corresponding</span>
                          <span class="comment">% values in units of pixels.  We store both for speed later. If a mask will be specified to define</span>
                          <span class="comment">% the arc-length origin it must be applied prior to populating polyFitsROI.</span>
                          <span class="comment">% Populated by method fit_polys_roi().</span>

        <span class="comment">% polyFitsMask:</span>
        <span class="comment">% Cell array of length length(trajectoryIDs), of format:</span>
        <span class="comment">%</span>
        <span class="comment">% There is generally a noisy edge to the tracked</span>
        <span class="comment">% whiskers on the side of whisker pad, which can interfere</span>
        <span class="comment">% with proper measurement of radial distances. For each whisker</span>
        <span class="comment">% for each trial, can specify here a polynomial in image coordinate</span>
        <span class="comment">% space to "mask out" the noisy edge. That is, radial distance for</span>
        <span class="comment">% purposes of mean theta and mean kappa measurements will be measured starting</span>
        <span class="comment">% at the intersection of the tracked whisker with this masking polynomial</span>
        <span class="comment">% if the whisker in fact crosses the masking polynomial. I.e., the radial</span>
        <span class="comment">% distance is r_new = r - r_intersection where r_new is the</span>
        <span class="comment">% new radial distance used in mean theta and mean kappa measurements, r is the</span>
        <span class="comment">% original radial distance, and r_intersection is the point of intersection</span>
        <span class="comment">% between the fitted whisker and the masking polynomial. If there is no intersection,</span>
        <span class="comment">% then r_new = r.  Also, if polyFitsMask is empty (or is empty for a given whisker)</span>
        <span class="comment">% then r_new = r.</span>
        <span class="comment">%</span>
        <span class="comment">% Ultimately, may want to do this separately for every frame, perhaps after</span>
        <span class="comment">% face tracking.</span>
        <span class="comment">%</span>
        <span class="comment">% Polynomials can be of any order, and are reconstructed based on the number</span>
        <span class="comment">% of coefficients.</span>
        <span class="comment">% If polyFitsMask{k}{1} and polyFitsMask{k}{2} are NxM matrices where</span>
        <span class="comment">% M is the polynomial degree + 1 and N is the number of frames, then each frame</span>
        <span class="comment">% has its own mask. For instance, this could be used after face tracking.</span>
        <span class="comment">% If instead polyFitsMask{k}{1} and polyFitsMask{k}{2} are 1xM vectors</span>
        <span class="comment">% where M is the polynomial degree + 1, then the same mask is used for all</span>
        <span class="comment">% frames.</span>
        <span class="comment">%         polyFitsMask = {{[25 120],[157.5 31.5]},{[25 120],[157.5 31.5]},{[25 120],[157.5 31.5]}};</span>
        polyFitsMask = {};

        <span class="comment">%   maskTreatment: String describing treatment of mask. Or, can be cell array</span>
        <span class="comment">%                   of strings, of same length as obj.trajectoryIDs and with</span>
        <span class="comment">%                   matching entries, in order to set maskTreatment differently</span>
        <span class="comment">%                   for different trajectory IDs.</span>
        <span class="comment">%               Values: 'none', 'mask', 'maskNaN'.</span>
        <span class="comment">%                   none: Ignore the mask.</span>
        <span class="comment">%                   mask: Subtract from each radial distance in R</span>
        <span class="comment">%                      the radial distance at the intersection of</span>
        <span class="comment">%                      each fitted whisker with the mask.  If there is</span>
        <span class="comment">%                      no intersection for a given whisker, make no change</span>
        <span class="comment">%                      in the radial distance measurement: i.e. 0 is still</span>
        <span class="comment">%                      at the end. If obj.polyFitsMask is empty ({}), make</span>
        <span class="comment">%                      no change.</span>
        <span class="comment">%                   maskNaN: Same as mask except that if the whisker does</span>
        <span class="comment">%                      not intersect the mask in a given frame, set all its</span>
        <span class="comment">%                      values in R to NaN.</span>
        maskTreatment = <span class="string">'maskNaN'</span>; <span class="comment">% Alternatively, {'maskNaN','none','mask'} to set three (or more)</span>
        <span class="comment">% different trajectories to have three (or more) different treatments.</span>

        kappa = {}; <span class="comment">% Can always recompute from polyFits and q, but cache for speed.</span>
        theta = {}; <span class="comment">% Can always recompute from polyFits and q, but cache for speed.</span>
        follicleExtrapDistInPix = 0; <span class="comment">% Sets extrapolated distance past end of whisker, or past intersection of whisker</span>
                                     <span class="comment">% and mask if a mask is defined, at which follicle is estimated to be. Is not used until</span>
                                     <span class="comment">% recompute_cached_follicle_coords() is called.</span>
        follicleCoordsX = {}; <span class="comment">% Can always recompute, but cache for speed.</span>
        follicleCoordsY = {};
        barPos = []; <span class="comment">%  Inherited from WhiskerTrial. [frameNum XPosition YPosition]</span>
        barPosOffset = []; <span class="comment">% [x y], either 1X2 or nframesX2</span>
        barRadius = []; <span class="comment">% Inherited from WhiskerTrial.  In pixels. Must be radius of bar tracked by the bar tracker.</span>
        time = {};
        pxPerMm = 22.68; <span class="comment">%  Inherited from WhiskerTrial, but give default value.</span>
        faceSideInImage = <span class="string">'top'</span>; <span class="comment">% Inherited from WhiskerTrial, but give default value.</span>
        <span class="comment">% Can be: 'top', 'bottom', 'left','right'.</span>
        <span class="comment">% May need to make this a cell array of strings, one per trajectory ID</span>
        <span class="comment">% to handle case of tracked whiskers on both sides of head.</span>
        protractionDirection = <span class="string">'rightward'</span>;  <span class="comment">% Inherited from WhiskerTrial, but give default value.</span>
                                            <span class="comment">% Can be: 'downward','upward','rightward','leftward'.</span>

        useFlag = 1;
    <span class="keyword">end</span>

    <span class="keyword">properties</span> (Dependent = true)
        barPosClean <span class="comment">% Bar position after processing to clean up bar tracker errors/limitations.</span>
    <span class="keyword">end</span>

    <span class="keyword">methods</span> (Access = public)
        <span class="keyword">function</span> obj = WhiskerSignalTrial(w, varargin)
            <span class="comment">%</span>
            <span class="comment">% USAGE:</span>
            <span class="comment">%</span>
            <span class="comment">%   obj = WhiskerSignalTrial(w)</span>
            <span class="comment">%   obj = WhiskerSignalTrial(w, 'polyRoiInPix',[roiMin, roiMax])</span>
            <span class="comment">%   obj = WhiskerSignalTrial(w, 'polyRoiInPix',{[trajectoryIDs],[roiMin1, roiMax1], ...</span>
            <span class="comment">%                                     [roiMin2, roiMax2], ...</span>
            <span class="comment">%                                     [roiMin3, roiMax3], ...</span>
            <span class="comment">%                                     [roiMinN, roiMaxN]})</span>
            <span class="comment">%</span>
            <span class="comment">% INPUTS:</span>
            <span class="comment">%   w: a WhiskerTrial object.</span>
            <span class="comment">%</span>
            <span class="comment">%   Optional argument polyRoiInPix:</span>
            <span class="comment">%       Sets arc-length limits (in pixels) on which to perform secondary curve fitting.</span>
            <span class="comment">%       This argument can be given in two forms:</span>
            <span class="comment">%           (1) an 1x2 vector that gives the ROI for *all* whiskers; or</span>
            <span class="comment">%           (2) a cell array where first element is a vector of trajectory IDs</span>
            <span class="comment">%               (of length N) and subsequent elements comprise N 1x2 vectors</span>
            <span class="comment">%               giving ROIs for the trajectory IDs specified in the first</span>
            <span class="comment">%               element (respectively).</span>
            <span class="comment">%       Limits are inclusive.</span>
            <span class="comment">%</span>
            <span class="comment">%   If WhiskerSignalTrial(w) is called without 'polyRoiInPix'</span>
            <span class="comment">%   argument, and w.polyFitsROI is empty (i.e.,</span>
            <span class="comment">%   fit_polys_roi() method of WhiskerTrial w was not called earlier), then</span>
            <span class="comment">%   an error is given.  A WhiskerSignalTrial requires</span>
            <span class="comment">%   polynomials to be fitted to the whiskers.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            p = inputParser;
            p.addOptional(<span class="string">'w'</span>, @(x) isa(x,<span class="string">'Whisker.WhiskerTrial'</span>));
            p.addParamValue(<span class="string">'polyRoiInPix'</span>, NaN);
            p.parse(varargin{:});

            <span class="keyword">if</span> nargin==0
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(w.polyFitsROI) &amp;&amp; any(isnan(p.Results.polyRoiInPix))
                error([<span class="string">'If ''fit_polys_roi()'' has not already been called on '</span> <span class="keyword">...</span>
                    <span class="string">'WhiskerSignalTrial argument, then argument ''polyRoiInPix'' must be given.'</span>])
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~iscell(p.Results.polyRoiInPix) <span class="comment">% Single ROI given; not specified individually for different trajectories.</span>
                tidList = w.trajectoryIDs;
                roiAll = cell(1,length(tidList));
                <span class="comment">% Copy ROI for each trajectory:</span>
                <span class="keyword">for</span> k=1:length(roiAll)
                    roiAll{k} = p.Results.polyRoiInPix;
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                tidList = p.Results.polyRoiInPix{1};
                roiAll = p.Results.polyRoiInPix(2:end);
            <span class="keyword">end</span>

            <span class="keyword">if</span> length(tidList) ~= length(roiAll)
                error([<span class="string">'When given as a cell array, the first element of argument ''polyRoiInPix must be 1xN vector of trajectory IDs'</span> <span class="keyword">...</span>
                    <span class="string">'and subsequent elements must comprise N 1x2 vectors giving the ROI for each trajectory.'</span>]);
            <span class="keyword">end</span>

            <span class="keyword">if</span> length(tidList) ~= length(w.trajectoryIDs)
                error(<span class="string">'Number of trajectory IDs specified in varagin{1} does not match number of trajectory IDs in WhiskerTrial argument w.'</span>)
            <span class="keyword">end</span>

            obj.trialNum = w.trialNum;
            obj.trialType = w.trialType;
            obj.whiskerNames = w.whiskerNames;
            obj.trajectoryIDs = w.trajectoryIDs;
            obj.framePeriodInSec = w.framePeriodInSec;
            obj.mouseName = w.mouseName;
            obj.sessionName = w.sessionName;
            obj.trackerFileName = w.trackerFileName;
            obj.faceSideInImage = w.faceSideInImage;
            obj.protractionDirection = w.protractionDirection;
            obj.pxPerMm = w.pxPerMm;
            obj.barPos = w.barPos;
            obj.barRadius = w.barRadius;
            obj.barPosOffset = w.barPosOffset;
            obj.polyFitsMask = w.polyFitsMask;

            ntraj = length(obj.trajectoryIDs);

            obj.theta = cell(1,ntraj);
            obj.kappa = cell(1,ntraj);
            obj.time = cell(1,ntraj);

            <span class="keyword">for</span> k=1:ntraj
                tid = obj.trajectoryIDs(k);
                ind = find(tidList==tid);
                <span class="keyword">if</span> numel(ind) ~= 1
                    error(<span class="string">'Trajectory either not found or found multiple times; argument varargin{1} must be incorrect.'</span>)
                <span class="keyword">end</span>

                disp([<span class="string">'Fitting polys for TID = '</span> int2str(tid)])

                <span class="keyword">if</span> ~isnan(roiAll{ind})
                    w.fit_polys_roi(roiAll{ind});
                <span class="keyword">end</span>

                obj.polyFits = w.polyFits; <span class="comment">% Put this here so that if WhiskerTrial had empty polyFits property</span>
                                            <span class="comment">% before calling w.mean_theta_and_kappa, it will now be transferred</span>
                                            <span class="comment">% to WhiskerSignalTrial.</span>
                obj.polyFitsROI = w.polyFitsROI;
                obj.time{k} = w.get_time(tid);

            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> obj = recompute_cached_mean_theta_kappa(obj, varargin)
            <span class="comment">%</span>
            <span class="comment">%  obj = recompute_cached_mean_theta_kappa(obj, varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% Recompute obj.theta, obj.kappa, and obj.time.</span>
            <span class="comment">%</span>
            <span class="comment">%   obj = recompute_cached_mean_theta_kappa(obj)</span>
            <span class="comment">%   obj = recompute_cached_mean_theta_kappa(obj, [xmin_position, xmax_position, xmin_curv, xmax_curv])</span>
            <span class="comment">%   obj = recompute_cached_mean_theta_kappa(obj, {[trajectoryIDs],[xmin_position1, xmax_position1, xmin_curv1, xmax_curv1], ...</span>
            <span class="comment">%                                     [xmin_position2, xmax_position2, xmin_curv2, xmax_curv2], etc})</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   varargin{1}: pixel x-limits on which compute position and curvature.</span>
            <span class="comment">%       Sets an x-dimension ROI. This argument can be given in two forms:</span>
            <span class="comment">%           (1) an 1x4 vector that gives x-coordinates for *all* whiskers; or</span>
            <span class="comment">%           (2) a cell array where first element is a vector of trajectory IDs</span>
            <span class="comment">%               (of length N) and subsequent elements comprise N 1x4 vectors</span>
            <span class="comment">%               giving x-coordinates for the trajectory IDs specified in the first</span>
            <span class="comment">%               element (respectively).</span>
            <span class="comment">%</span>
            <span class="comment">%  UPDATE DESCRIPTION OF LIMITS WITH FOLLOWING:</span>
            <span class="comment">%   radial_window_kappa: 2x1 vector giving arc length region of whisker to</span>
            <span class="comment">%   average over for mean kappa measurment, in format [startDistance stopDistance].</span>
            <span class="comment">%   Values are inclusive and in units of pixels. If empty ([]), averages over</span>
            <span class="comment">%   the whole whisker.</span>
            <span class="comment">%</span>
            <span class="comment">%   radial_window_theta: 2x1 vector giving arc length region of whisker to</span>
            <span class="comment">%   average over for mean kappa measurment, in format [startDistance stopDistance].</span>
            <span class="comment">%   Values are inclusive and in units of pixels. If empty ([]), averages over</span>
            <span class="comment">%   the whole whisker, which is not likely useful for theta.</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> nargin &gt; 2
                error(<span class="string">'Too many input arguments.'</span>)
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin==1
                tidList = obj.trajectoryIDs;
                XValLimsAll = cell(1,length(tidList)); <span class="comment">% If no x-coordinates given for region of interest, all elts will be left empty.</span>
            <span class="keyword">else</span>
                xroi = varargin{1};
                <span class="keyword">if</span> ~iscell(xroi) <span class="comment">% Single set of x-coordinates given; not specified individually for different trajectories.</span>
                    tidList = obj.trajectoryIDs;
                    XValLimsAll = cell(1,length(tidList));
                    <span class="comment">% Copy single set of x-coordinates for each trajectory:</span>
                    <span class="keyword">for</span> k=1:length(XValLimsAll)
                        XValLimsAll{k} = xroi;
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    tidList = xroi{1};
                    XValLimsAll = xroi(2:end);
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> length(tidList) ~= length(XValLimsAll)
                error([<span class="string">'First element of varargin{1} must be 1xN vector of trajectory IDs'</span> <span class="keyword">...</span>
                    <span class="string">'and subsequent elements must comprise N 1x4 vectors giving x-coordinates'</span>]);
            <span class="keyword">end</span>

            <span class="keyword">if</span> length(tidList) ~= length(obj.trajectoryIDs)
                error(<span class="string">'Number of trajectory IDs specified in varagin{1} does not match number of trajectory IDs in WhiskerTrial argument w.'</span>)
            <span class="keyword">end</span>

            ntraj = length(obj.trajectoryIDs);

            obj.theta = cell(1,ntraj);
            obj.kappa = cell(1, ntraj);

            <span class="keyword">for</span> k=1:ntraj
                tid = obj.trajectoryIDs(k);
                ind = find(tidList==tid);
                <span class="keyword">if</span> numel(ind) ~= 1
                    error(<span class="string">'Trajectory either not found or found multiple times; argument varargin{1} must be incorrect.'</span>)
                <span class="keyword">end</span>
                XValLims = XValLimsAll{ind};
                <span class="keyword">if</span> isempty(XValLims)
                    XValLimsPosition = [];
                    XValLimsCurv = [];
                <span class="keyword">else</span>
                    XValLimsPosition = XValLims(1:2);
                    XValLimsCurv = XValLims(3:4);
                <span class="keyword">end</span>

                disp([<span class="string">'Traj='</span> int2str(tid)])
                disp([<span class="string">'XValLimsPosition = '</span> num2str(XValLimsPosition)])
                disp([<span class="string">'XValLimsCurv = '</span> num2str(XValLimsCurv)])

                [t, theta, kappa] = obj.mean_theta_and_kappa(tid, XValLimsPosition, XValLimsCurv);

                obj.theta{k} = theta;
                obj.kappa{k} = kappa;
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> obj = recompute_cached_follicle_coords(obj, extrap_distance, varargin)
            <span class="comment">%</span>
            <span class="comment">%  obj = recompute_cached_follicle_coords(obj, extrap_distance, varargin)</span>
            <span class="comment">%  obj = recompute_cached_follicle_coords(obj, extrap_distance)</span>
            <span class="comment">%  obj = recompute_cached_follicle_coords(obj, extrap_distance, tidList)</span>
            <span class="comment">%  obj = recompute_cached_follicle_coords(obj, extrap_distance, tidList, roi)</span>
            <span class="comment">%</span>
            <span class="comment">% Recomputes obj.follicleCoords.</span>
            <span class="comment">%</span>
            <span class="comment">%  INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   extrap_distance: The distance in units of pixels</span>
            <span class="comment">%        to extrapolate the whisker in order to get the</span>
            <span class="comment">%        (x,y) coordinates of the follicle. Extrapolation is</span>
            <span class="comment">%        based on the angle theta at the base of the whisker</span>
            <span class="comment">%        (radial distance = 0) if no mask is defined or if the</span>
            <span class="comment">%        whisker does not cross the mask.  Otherwise</span>
            <span class="comment">%        extrapolation is based on theta at the intersection of</span>
            <span class="comment">%        the whisker and the mask.</span>
            <span class="comment">%</span>
            <span class="comment">%   varargin{1}: Optional vector of trajectoryIDs. If varargin{1}</span>
            <span class="comment">%       is not given or is empty ([]), all trajectoryIDs in obj.trajectoryIDs</span>
            <span class="comment">%       are used.</span>
            <span class="comment">%</span>
            <span class="comment">%   varargin{2}: Optional arc-length region of interest in which to</span>
            <span class="comment">%        fit a straight line to the whisker. This straight line is</span>
            <span class="comment">%        then extrapolated by extrap_distance to estimate the follicle</span>
            <span class="comment">%        position. Units of pixels.</span>
            <span class="comment">%        ** IMPORTANT**: Giving this varargin{2} argument</span>
            <span class="comment">%        fundamentally changes how the follicle position is estimated.</span>
            <span class="comment">%        If varargin{2} is *not* given, the most proximal theta value is used</span>
            <span class="comment">%        to set the direction of extrapolation.  See obj.get_follicle_coords().</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> nargin &gt; 4
                error(<span class="string">'Too many input arguments.'</span>)
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin &gt; 3
                roi = varargin{2};
                fitLine = 1;
            <span class="keyword">else</span>
                fitLine = 0;
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargin==2
                tidList = obj.trajectoryIDs;
            <span class="keyword">else</span>
                tidList = varargin{1};
                <span class="keyword">if</span> isempty(tidList)
                    tidList = obj.trajectoryIDs;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> extrap_distance &lt;= 0 || length(extrap_distance) &gt; 1
                error(<span class="string">'Argument extrap_distance must be a positive scaler.'</span>)
            <span class="keyword">end</span>

            obj.follicleExtrapDistInPix = extrap_distance; <span class="comment">% Cache this argument in an object property.</span>
                                                           <span class="comment">% We need it later when computing moment of inertia.</span>

            ntraj = length(obj.trajectoryIDs);
            obj.follicleCoordsX = cell(1,ntraj);
            obj.follicleCoordsY = cell(1,ntraj);
            <span class="keyword">if</span> isempty(obj.time) <span class="comment">% May have already been populated by recompute_cached_mean_theta_kappa()</span>
                obj.time = cell(1,ntraj);
            <span class="keyword">end</span>

            <span class="keyword">for</span> k=1:length(tidList)
                tid = tidList(k);
                <span class="keyword">if</span> ~ismember(tid,obj.trajectoryIDs)
                    error([<span class="string">'Trajectory ID '</span> int2str(tid) <span class="string">' not found.'</span>])
                <span class="keyword">end</span>

                disp([<span class="string">'Computing follicle coordinates for TID = '</span> int2str(tid)])

                <span class="keyword">if</span> fitLine==1
                    [y,x,t] = obj.get_follicle_coords(tid,extrap_distance,roi);
                <span class="keyword">else</span>
                    [y,x,t] = obj.get_follicle_coords(tid,extrap_distance);
                <span class="keyword">end</span>

                obj.follicleCoordsX{k} = x;
                obj.follicleCoordsY{k} = y;
                <span class="keyword">if</span> isempty(obj.time{k}) <span class="comment">% May have already been populated by recompute_cached_mean_theta_kappa()</span>
                    obj.time{k} = t;
                <span class="keyword">end</span>

            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> tid = name2tid(obj, whisker_name)
            <span class="keyword">if</span> ~ischar(whisker_name)
                error(<span class="string">'Argument whisker_name must be a string.'</span>)
            <span class="keyword">end</span>
            <span class="keyword">if</span> numel(obj.whiskerNames) ~= numel(obj.trajectoryIDs)
                error(<span class="string">'This WhiskerSignalTrial does not have matching whiskerNames and trajectoryIDs.'</span>)
            <span class="keyword">end</span>
            tid = obj.trajectoryIDs( strmatch(whisker_name, obj.whiskerNames) );
        <span class="keyword">end</span>

        <span class="keyword">function</span> whisker_name = tid2name(obj, trajectory_id)
            <span class="keyword">if</span> ~isnumeric(trajectory_id)
                error(<span class="string">'Argument trajectory_id must be an integer.'</span>)
            <span class="keyword">end</span>
            <span class="keyword">if</span> numel(trajectory_id) &gt; 1
                error(<span class="string">'Only one trajectory_id is allowed.'</span>)
            <span class="keyword">end</span>
            whisker_name = obj.whiskerNames(obj.trajectoryIDs==trajectory_id);
        <span class="keyword">end</span>

        <span class="keyword">function</span>  [pkVal,pkTime,pkBinarySignal] = get_whisk_peaks(obj,tid)
            <span class="comment">%</span>
            <span class="comment">%   [pkVal,pkTime,pkBinarySignal] = get_whisk_peaks(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            [y,t] = obj.get_position(tid);
            thresh = .01; <span class="comment">% Should make argument. ***</span>

            bandPassCutOffsInHz = [10 25];
            sampleRate = 500; <span class="comment">% Should read from data.***</span>
            W1 = bandPassCutOffsInHz(1) / (sampleRate/2);
            W2 = bandPassCutOffsInHz(2) / (sampleRate/2);
            [b,a]=butter(2,[W1 W2]);

            y = filtfilt(b,a,y);

            [pkVal,pkInd] = Whisker.lmax(y,0);

            ind = abs(pkVal) &gt; thresh;
            pkVal = pkVal(ind);
            pkInd = pkInd(ind);

            pkTime = t(pkInd);

            pkBinarySignal = zeros(size(t));
            pkBinarySignal(pkInd) = 1;
        <span class="keyword">end</span>

        <span class="keyword">function</span> [f,Y] = get_FFT_position(obj,tid)
            <span class="comment">%</span>
            <span class="comment">%   [f,Y] = get_FFT_position(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            Fs = 1 / obj.framePeriodInSec;
            [y,t] = obj.get_position(tid);

            <span class="comment">% Check if frames are evenly spaced. If not, must interpolate theta for</span>
            <span class="comment">% missing frames prior to spectral analysis:</span>
            frames = t ./ obj.framePeriodInSec;
            <span class="keyword">if</span> length(unique(diff(frames))) &gt; 1
                newframes = min(frames):max(frames);
                y = interp1(frames,y,newframes,<span class="string">'linear'</span>);
            <span class="keyword">end</span>

            L = length(y);
            <span class="comment">% Mean-subtract signal to eliminate DC term of transform:</span>
            y = y - mean(y);
            NFFT = 2^nextpow2(L);
            <span class="comment">%             h=hamming(L,'periodic')';</span>
            <span class="comment">%             y = y.*h;</span>
            Y = fft(y,NFFT)/L;
            Y = 2*abs(Y(1:NFFT/2));
            f = Fs/2*linspace(0,1,NFFT/2);
        <span class="keyword">end</span>

        <span class="keyword">function</span> r = get_spectral_power_band_position(obj,tid,band)
            <span class="comment">%</span>
            <span class="comment">%   r = get_spectral_power_band_position(obj,tid,band)</span>
            <span class="comment">%</span>
            <span class="comment">% band: [minFreqInclusive maxFreqInclusive]</span>
            <span class="comment">%</span>
            [f,Y] = get_FFT_position(obj,tid);
            ind = f&gt;=band(1) &amp; f&lt;=band(2);
            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Invalid frequency band'</span>)
            <span class="keyword">end</span>
            r = sum(Y(ind));
        <span class="keyword">end</span>

        <span class="keyword">function</span> r = curvatureDot(obj,varargin)
            <span class="comment">%</span>
            <span class="comment">%   r = curvatureDot(obj,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: vector of trajectory IDs.</span>
            <span class="comment">%</span>
            <span class="comment">% If only a single trajectory is specified, r is a vector.</span>
            <span class="comment">% If multiple trajectories are specified, r is a cell array</span>
            <span class="comment">% of vectors.</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> nargin &gt; 1
                tid = varargin{1};
            <span class="keyword">else</span>
                tid = obj.trajectoryIDs;
            <span class="keyword">end</span>
            <span class="keyword">if</span> isempty(tid)
                tid = obj.trajectoryIDs;
            <span class="keyword">end</span>

            ntraj = length(tid);
            <span class="keyword">if</span> ntraj &gt; 1
                r = cell(1,ntraj);
                <span class="keyword">for</span> k=1:ntraj
                    ind = obj.trajectoryIDs==tid(k);
                    <span class="keyword">if</span> max(ind) &lt; 1
                        error(<span class="string">'Trajectory ID was not found.'</span>)
                    <span class="keyword">end</span>
                    t = obj.time{ind};
                    r{k} = [0 diff(obj.kappa{ind})] ./ [0 diff(t)];
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                ind = obj.trajectoryIDs==tid;
                <span class="keyword">if</span> max(ind) &lt; 1
                    error(<span class="string">'Trajectory ID was not found.'</span>)
                <span class="keyword">end</span>
                t = obj.time{ind};
                r = [0 diff(obj.kappa{ind})] ./ [0 diff(t)];
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_position(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">%   [y,t] = get_position(obj,tid,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% tid: Trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Optional smoothing span, in frames.</span>
            <span class="comment">%               If not specified there is no smoothing. Should be</span>
            <span class="comment">%               an odd number (see 'help smooth').</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% Returns angle with respect to y-axis of coordinate plane</span>
            <span class="comment">% in which slope is computed (i.e., of the high-speed video</span>
            <span class="comment">% image). Whisker angle is with respect to mouse midline if</span>
            <span class="comment">% y-axis of image is parallel with mouse midline.</span>
            <span class="comment">%</span>
            <span class="comment">% If a *decrease* in slope in image coordinates cooresponds to</span>
            <span class="comment">% whisker protraction, then this function returns increasing</span>
            <span class="comment">% angles during protraction.</span>
            <span class="comment">%</span>
            <span class="comment">% Angle is 0 deg when whisker is perpendicular to midline,</span>
            <span class="comment">% increases to +90 deg with protraction all the way to parallel</span>
            <span class="comment">% to the midline, and decreases to -90 deg with retraction all</span>
            <span class="comment">% the way to the midline.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>

            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
            y = obj.theta{ind};

            <span class="keyword">if</span> nargin &gt; 2
                span = varargin{1};
                <span class="keyword">if</span> span &lt; 3
                    error(<span class="string">'Smoothing window in varargin{2} should be an odd number &gt; 3.'</span>)
                <span class="keyword">end</span>
                <span class="keyword">if</span> mod(span,2)==0
                    disp(<span class="string">'Smoothing window in varargin{2} should be an odd number. Smooth() will round it.'</span>)
                <span class="keyword">end</span>
                <span class="comment">% Check if frames are evenly spaced. If not, must interpolate theta for</span>
                <span class="comment">% missing frames prior to applying a moving average. Will do that, then</span>
                <span class="comment">% take only smoothed theta values at the original (non-interpolated)</span>
                <span class="comment">% frames.</span>
                frames = t ./ obj.framePeriodInSec;
                <span class="keyword">if</span> length(unique(diff(frames))) &gt; 1
                    newframes = min(frames):max(frames);
                    newy = interp1(frames,y,newframes,<span class="string">'linear'</span>);
                    yy = smooth(newy,span,<span class="string">'moving'</span>)';
                    y = interp1(newframes,yy,frames,<span class="string">'linear'</span>); <span class="comment">% could use ismember instead</span>
                <span class="keyword">else</span>
                    y = smooth(y,span,<span class="string">'moving'</span>)';
                <span class="keyword">end</span>
                <span class="comment">% Sanity check:</span>
                <span class="keyword">if</span> length(y) ~= length(t)
                    error(<span class="string">'y and t are of unequal lengths.'</span>)
                <span class="keyword">end</span>

            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_mean_position(obj)
            <span class="comment">%</span>
            <span class="comment">%   [y,t] = get_mean_position(obj)</span>
            <span class="comment">%</span>
            <span class="comment">%   y is the ***mean position of all whiskers*** (tids) in trial.</span>
            <span class="comment">%   This is for use, e.g., in determining whether there is overall</span>
            <span class="comment">%   whisking after fully-automated tracking.</span>
            <span class="comment">%</span>
            <span class="comment">% Returns angle of average whisker with respect to y-axis of coordinate plane</span>
            <span class="comment">% in which slope is computed (i.e., of the high-speed video</span>
            <span class="comment">% image). Whisker angle is with respect to mouse midline if</span>
            <span class="comment">% y-axis of image is parallel with mouse midline.</span>
            <span class="comment">%</span>
            <span class="comment">% If a *decrease* in slope in image coordinates cooresponds to</span>
            <span class="comment">% whisker protraction, then this function returns increasing</span>
            <span class="comment">% angles during protraction.</span>
            <span class="comment">%</span>
            <span class="comment">% Angle is 0 deg when whisker is perpendicular to midline,</span>
            <span class="comment">% increases to +90 deg with protraction all the way to parallel</span>
            <span class="comment">% to the midline, and decreases to -90 deg with retraction all</span>
            <span class="comment">% the way to the midline.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            T = cell2mat(obj.time); Y = cell2mat(obj.theta);
            r = Shared.tapply([T' Y']);
            t = r(:,1); y = r(:,2);
        <span class="keyword">end</span>

        <span class="keyword">function</span> [th,t] = get_fitted_line_angle_in_roi(obj,tid,roi)
            <span class="comment">%</span>
            <span class="comment">%    [th,t] = get_fitted_line_angle_in_roi(obj,tid,roi)</span>
            <span class="comment">%</span>
            <span class="comment">%  INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   tid: Trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">%   roi: Arc-length region of interest in which to</span>
            <span class="comment">%        fit a straight line to the whisker. In units of pixels.</span>
            <span class="comment">%        The location of arc-length 0 depends on the mask settings.</span>
            <span class="comment">%        See documentation for object property maskTreatment.</span>
            <span class="comment">%</span>
            <span class="comment">%   RETURNS:</span>
            <span class="comment">%</span>
            <span class="comment">%   th: Whisker angle, theta, in degrees. Angle of 0 means that</span>
            <span class="comment">%       the whisker is parallel to the medial-lateral axis.</span>
            <span class="comment">%       Protraction corresponds to increasing angle.</span>
            <span class="comment">%       The value of obj.faceSideInImage must be set correctly to</span>
            <span class="comment">%       get correct angles from this method.</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> numel(roi) ~= 2
                error(<span class="string">'Argument roi must be a 2-element vector giving an arc-length ROI.'</span>)
            <span class="keyword">elseif</span> roi(2) &lt; roi(1)
                error(<span class="string">'Argument roi  must give an arc-length ROI in format: [startInPix stopInPix].'</span>)
            <span class="keyword">end</span>

            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.polyFits)
                error(<span class="string">'obj.polyFits is empty.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> ~ischar(obj.faceSideInImage)
                error(<span class="string">'(x,y) coordinate specification of face location not yet implemented.'</span>)
            <span class="keyword">end</span>

            t = obj.get_time(tid);

            <span class="keyword">if</span> all(isnan(t))
                disp([<span class="string">'All time values for trajectoryID='</span> int2str(tid) <span class="string">' are NaN; perhaps '</span><span class="keyword">...</span>
                    <span class="string">'nothing is tracked for this trial. Returning NaN.'</span>])
                th = NaN;
                t = NaN;
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
            rind = cellfun(@(x) find(x &gt;= roi(1) &amp; x &lt;= roi(2)), R,<span class="string">'UniformOutput'</span>,false);


            nframes = length(t);

            th = zeros(1,nframes);

            q = linspace(0,1);

            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};

            <span class="keyword">for</span> k=1:nframes
                <span class="comment">%                 disp(['Frame=' int2str(k)])</span>
                px = fittedX(k,:);
                py = fittedY(k,:);

                xall = polyval(px,q);
                yall = polyval(py,q);

                <span class="comment">% If maskTreatment property is set to 'maskNaN', and the whisker</span>
                <span class="comment">% does not cross the mask, then all the radial distance values in R</span>
                <span class="comment">% for that whisker for that frame will be set to NaN.  In that case,</span>
                <span class="comment">% there will be an empty element in rind.  Propagate the NaN here:</span>
                <span class="keyword">if</span> isempty(rind{k})
                    th(k) = NaN;
                    <span class="keyword">continue</span>
                <span class="keyword">end</span>

                x = xall(rind{k});
                y = yall(rind{k});

                <span class="keyword">if</span> numel(x) &lt; 2 || numel(y) &lt; 2
                    th(k) = NaN;
                    <span class="keyword">continue</span>
                <span class="keyword">end</span>

                <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) || strcmp(obj.faceSideInImage,<span class="string">'left'</span>)
                    <span class="keyword">if</span> numel(unique(x)) &lt; 2
                        disp(<span class="string">'Found whisker at either +180 deg or -180 deg; ambiguous--setting to NaN'</span>)
                    <span class="keyword">end</span>
                <span class="keyword">end</span>

                <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>) <span class="comment">%</span>
                    p = polyfit(x,y,1);
                    th(k) = atand(p(1));
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>) <span class="comment">%</span>
                    p = polyfit(x,y,1);
                    th(k) = -atand(p(1));
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>) <span class="comment">%</span>
                    p = polyfit(x,y,1);
                    th(k) = -atand(p(1));
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>) <span class="comment">%</span>
                    p = polyfit(x,y,1);
                    th(k) = atand(p(1));
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>) <span class="comment">%</span>
                    p = polyfit(y,x,1);
                    th(k) = atand(p(1));
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>) <span class="comment">%</span>
                    p = polyfit(y,x,1);
                    th(k) = -atand(p(1));
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>) <span class="comment">%</span>
                    p = polyfit(y,x,1);
                    th(k) = -atand(p(1));
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>) <span class="comment">%</span>
                    p = polyfit(y,x,1);
                    th(k) = atand(p(1));
                <span class="keyword">else</span>
                    error(<span class="string">'Invalid value of obj.faceSideInImage.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            ind = isinf(th);
            <span class="keyword">if</span> sum(ind) &gt; 0
                disp(<span class="string">'Found frames with whisker at either +180 deg or -180 deg; ambiguous--setting to NaN'</span>)
                th(ind) = NaN;
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,x,t] = get_follicle_coords(obj,tid,extrap_distance,varargin)
            <span class="comment">%</span>
            <span class="comment">%    [y,x,t] = get_follicle_coords(obj,tid,extrap_distance,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">%  INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   tid: Trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">%   extrap_distance: The distance in units of pixels</span>
            <span class="comment">%        to extrapolate the whisker in order to get the</span>
            <span class="comment">%        (x,y) coordinates of the follicle. Extrapolation is</span>
            <span class="comment">%        based on the angle theta at the base of the whisker</span>
            <span class="comment">%        (radial distance = 0) if no mask is defined or if the</span>
            <span class="comment">%        whisker does not cross the mask.  Otherwise</span>
            <span class="comment">%        extrapolation is based on theta at the intersection of</span>
            <span class="comment">%        the whisker and the mask.</span>
            <span class="comment">%</span>
            <span class="comment">%   varargin{1}: Optional arc-length region of interest in which to</span>
            <span class="comment">%        fit a straight line to the whisker. This straight line is</span>
            <span class="comment">%        then extrapolated by extrap_distance to estimate the follicle</span>
            <span class="comment">%        position. Units of pixels.</span>
            <span class="comment">%        ** IMPORTANT**: Giving this varargin{1} argument</span>
            <span class="comment">%        fundamentally changes how the follicle position is estimated.</span>
            <span class="comment">%        If varargin{1} is *not* given, the most proximal theta value is used</span>
            <span class="comment">%        (as described above) to set the direction of extrapolation.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%  RETURNS:</span>
            <span class="comment">%</span>
            <span class="comment">% y: The y coordinate in image pixels of the follicle for each</span>
            <span class="comment">%    time point (i.e. frame).</span>
            <span class="comment">%</span>
            <span class="comment">% x: The x coordinate in image pixels of the follicle for each</span>
            <span class="comment">%    time point.</span>
            <span class="comment">%</span>
            <span class="comment">% t: The time of each observation in x,y.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            npoints = 100;  <span class="comment">% Number of points to use in reconstructing whisker from fitted polynomials.</span>
                            <span class="comment">% Sets the resolution at which the follicle coordinates can be estimated when.</span>
                            <span class="comment">% A higher value is better but runs more slowly. Doesn't have any effect unless</span>
                            <span class="comment">% a mask is being used.</span>
            <span class="keyword">if</span> nargin &lt; 4
                fitLine = 0;
            <span class="keyword">else</span>
                fitLine = 1;
                roiLine = varargin{1};
                <span class="keyword">if</span> numel(roiLine) ~= 2
                    error(<span class="string">'varargin{1} must be a 2-element vector giving an arc-length ROI.'</span>)
                <span class="keyword">elseif</span> roiLine(2) &lt; roiLine(1)
                    error(<span class="string">'varargin{1} must give an arc-length ROI in format: [startInPix stopInPix].'</span>)
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.polyFits)
                error(<span class="string">'obj.polyFits is empty.'</span>)
            <span class="keyword">end</span>

<span class="comment">%             if all(isnan(obj.theta{ind}))</span>
<span class="comment">%                 disp(['All theta values for trajectoryID=' int2str(tid) ' are NaN; perhaps '...</span>
<span class="comment">%                     'nothing is tracked for this trial. Setting face follicle coordinates to NaN.'])</span>
<span class="comment">%                 x = NaN;</span>
<span class="comment">%                 y = NaN;</span>
<span class="comment">%                 t = NaN;</span>
<span class="comment">%                 return</span>
<span class="comment">%             end</span>

            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid,npoints);
            rind = cellfun(@(x) find(x==0), R,<span class="string">'UniformOutput'</span>,false);
            emp = find(cellfun(@isempty, rind));

            <span class="keyword">if</span> fitLine==1 <span class="comment">% Get angle based on line fitted to ROI.</span>
                [th,t] = obj.get_fitted_line_angle_in_roi(tid,roiLine);
                <span class="keyword">if</span> ~isempty(emp)
                    <span class="keyword">for</span> q=1:length(emp)
                        th(emp(q)) = NaN;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">else</span> <span class="comment">% Use theta at point where arc-length = 0.</span>
                th = cellfun(@(x,y) x(y), THETA, rind,<span class="string">'UniformOutput'</span>,false);
                <span class="keyword">if</span> ~isempty(emp)
                    <span class="comment">% If maskTreatment property is set to 'maskNaN', and the whisker</span>
                    <span class="comment">% does not cross the mask, then all the radial distance values in R</span>
                    <span class="comment">% for that whisker for that frame will be set to NaN.  In that case,</span>
                    <span class="comment">% there will be an empty element in rind. Propagate the NaN here:</span>
                    <span class="keyword">for</span> q=1:length(emp)
                        th{emp(q)} = NaN;
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
                th = cell2mat(th);
                t = obj.get_time(tid);
            <span class="keyword">end</span>

            nframes = length(t);

            <span class="keyword">if</span> nframes==0
                disp([<span class="string">'Number of frames for trajectoryID='</span> int2str(tid) <span class="string">' is 0; perhaps '</span><span class="keyword">...</span>
                    <span class="string">'nothing is tracked for this trial. Setting face follicle coordinates to NaN.'</span>])
                x = NaN;
                y = NaN;
                t = NaN;
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            x = zeros(1,nframes);
            y = zeros(1,nframes);

            q = linspace(0,1,npoints);

            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};

            <span class="keyword">for</span> k=1:nframes
                <span class="comment">%                 disp(['Frame=' int2str(k)])</span>
                px = fittedX(k,:);
                py = fittedY(k,:);

                xall = polyval(px,q);
                yall = polyval(py,q);


                <span class="comment">% If maskTreatment property is set to 'maskNaN', and the whisker</span>
                <span class="comment">% does not cross the mask, then all the radial distance values in R</span>
                <span class="comment">% for that whisker for that frame will be set to NaN.  In that case,</span>
                <span class="comment">% there will be an empty element in rind.  Propagate the NaN here:</span>
                <span class="keyword">if</span> isempty(rind{k})
                    x(k) = NaN;
                    y(k) = NaN;
                    <span class="comment">% Alternatively, could just use (x,y,theta) values for point closest to</span>
                    <span class="comment">% face by uncommenting next two lines:</span>
                    <span class="comment">% xall(end);</span>
                    <span class="comment">% xall(end);</span>
                <span class="keyword">else</span>
                    x(k) = xall(rind{k});
                    y(k) = yall(rind{k});
                <span class="keyword">end</span>
            <span class="keyword">end</span>


            <span class="comment">% Protraction means theta is increasing.</span>
            <span class="comment">% Theta is 0 when perpendicular to the midline of the mouse.</span>

            <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>)
                deltax = -extrap_distance*sind(th);
                deltay = -extrap_distance*cosd(th);

            <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>)
                deltax = extrap_distance*sind(th);
                deltay = -extrap_distance*cosd(th);

            <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>)
                deltax = -extrap_distance*cosd(th);
                deltay = -extrap_distance*sind(th);

            <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>)
                deltax = -extrap_distance*cosd(th);
                deltay = extrap_distance*sind(th);

            <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>)
                deltax = extrap_distance*cosd(th);
                deltay = extrap_distance*sind(th);

            <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>)
                deltax = extrap_distance*cosd(th);
                deltay = -extrap_distance*sind(th);

            <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>)
                deltax = -extrap_distance*sind(th);
                deltay = extrap_distance*cosd(th);

            <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>)
                deltax = extrap_distance*sind(th);
                deltay = extrap_distance*cosd(th);
            <span class="keyword">else</span>
                error(<span class="string">'Invalid value of property ''faceSideInImage'' or ''protractionDirection'''</span>)
            <span class="keyword">end</span>

            x = x + deltax;
            y = y + deltay;
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_follicle_translation(obj,tid)
            <span class="comment">%</span>
            <span class="comment">%    [y,t] = get_follicle_translation(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%  INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   tid: Trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%  RETURNS:</span>
            <span class="comment">%</span>
            <span class="comment">% y: The distance the follicle has translated from the previous</span>
            <span class="comment">%    frame. Units of pixels.</span>
            <span class="comment">%</span>
            <span class="comment">% t: The time of each observation in y.</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.follicleCoordsX) || isempty(obj.follicleCoordsX)
                error([<span class="string">'obj.follicleCoordsX or obj.follicleCoordsY is empty. '</span> <span class="keyword">...</span>
                    <span class="string">'Must run obj.recompute_cached_follicle_coords before this method.'</span>])
            <span class="keyword">end</span>

            t = obj.get_time(tid);

            dx = [0 diff(obj.follicleCoordsX{ind})];
            dy = [0 diff(obj.follicleCoordsY{ind})];

            y = sqrt(dx.^2 + dy.^2);
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,x,t] = get_cached_follicle_coords(obj,tid)
            <span class="comment">%</span>
            <span class="comment">%    [y,x,t] = get_cached_follicle_coords(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%  INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   tid: Trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%  RETURNS:</span>
            <span class="comment">%</span>
            <span class="comment">% y: The y coordinate in image pixels of the follicle for each</span>
            <span class="comment">%    time point (i.e. frame).</span>
            <span class="comment">%</span>
            <span class="comment">% x: The x coordinate in image pixels of the follicle for each</span>
            <span class="comment">%    time point.</span>
            <span class="comment">%</span>
            <span class="comment">% t: The time of each observation in x,y.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.follicleCoordsX) || isempty(obj.follicleCoordsX)
                error([<span class="string">'obj.follicleCoordsX or obj.follicleCoordsY is empty. '</span> <span class="keyword">...</span>
                    <span class="string">'Must run obj.recompute_cached_follicle_coords before this method.'</span>])
            <span class="keyword">end</span>

            t = obj.get_time(tid);

            x = obj.follicleCoordsX{ind};
            y = obj.follicleCoordsY{ind};
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_curvature(obj,tid)
            <span class="comment">%</span>
            <span class="comment">%   [y,t] = get_curvature(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%   t: time in seconds.</span>
            <span class="comment">%   y: whisker curvature in units of pixels^(-1).</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
            y = obj.kappa{ind};
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_curvatureChange(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">%   [y,t] = get_curvatureChange(obj,tid,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">%   varargin{1}: Optional period to use for computing</span>
            <span class="comment">%       baseline curvature. Starts at 0 but user</span>
            <span class="comment">%       specifies endpoint in seconds. Default is 0.05 s.</span>
            <span class="comment">%</span>
            <span class="comment">%   t: time in seconds.</span>
            <span class="comment">%   y: whisker curvature change in units of pixels^(-1).</span>
            <span class="comment">%</span>

            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
            y = obj.kappa{ind};

            <span class="keyword">if</span> nargin &gt; 2
                baselinePeriodEnd = varargin{1};
            <span class="keyword">else</span>
                baselinePeriodEnd = 0.05;
            <span class="keyword">end</span>

            baseline = mean(y(t&lt;=baselinePeriodEnd));
            y = y-baseline;
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_curvatureDot(obj,tid)
            <span class="comment">%</span>
            <span class="comment">%   [y,t] = get_curvatureDot(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
            y = obj.curvatureDot(tid);
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_velocity(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">%   [y,t] = get_velocity(obj,tid,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% Angular velocity in degrees per second.</span>
            <span class="comment">%</span>
            <span class="comment">% tid: Trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Optional smoothing window, in frames,</span>
            <span class="comment">%              **for position (theta) signal.** Velocity is not</span>
            <span class="comment">%              separately smoothed. May want to smooth theta to</span>
            <span class="comment">%              eliminate noise due to whisker tracking artifacts.</span>
            <span class="comment">%               If not specified there is no smoothing. Should be</span>
            <span class="comment">%               an odd number (see 'help smooth').</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            <span class="comment">%             t = obj.time{ind};</span>
            <span class="keyword">if</span> nargin &gt; 2
                [theta,t] = obj.get_position(tid,varargin{1});
            <span class="keyword">else</span>
                [theta,t] = obj.get_position(tid);
            <span class="keyword">end</span>
            y = [0 diff(theta)] ./ [0 diff(t)]; <span class="comment">% in degrees/sec</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_velocity_medfilt(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">%   [y,t] = get_velocity_medfilt(obj,tid,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% Angular velocity in degrees per second, after filtering</span>
            <span class="comment">% position signal with a median filter.</span>
            <span class="comment">%</span>
            <span class="comment">% tid: Trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Optional smoothing window, in frames,</span>
            <span class="comment">%              **for position (theta) signal.** Velocity is not</span>
            <span class="comment">%              separately filtered. May want to filter theta to</span>
            <span class="comment">%              eliminate noise due to whisker tracking artifacts.</span>
            <span class="comment">%              Default is 3. Should be</span>
            <span class="comment">%               an odd number (see help medfilt1).</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            <span class="comment">%             t = obj.time{ind};</span>
            <span class="keyword">if</span> nargin &gt; 2
                span = varargin{1};
                <span class="keyword">if</span> mod(span,2)==0
                    disp(<span class="string">'Varargin{1}, should be odd; will be rounded down.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                span = 3;
            <span class="keyword">end</span>

            [theta,t] = obj.get_position(tid);

            <span class="comment">% Check if frames are evenly spaced. If not, must interpolate theta for</span>
            <span class="comment">% missing frames prior to applying filter. Will do that, then</span>
            <span class="comment">% take only smoothed theta values at the original (non-interpolated)</span>
            <span class="comment">% frames.</span>
            frames = t ./ obj.framePeriodInSec;
            <span class="keyword">if</span> length(unique(diff(frames))) &gt; 1
                newframes = min(frames):max(frames);
                newy = interp1(frames,theta,newframes,<span class="string">'linear'</span>);
                yy = medfilt1(newy,span)';
                y = interp1(newframes,yy,frames,<span class="string">'linear'</span>); <span class="comment">% could use ismember instead</span>
            <span class="keyword">else</span>
                y = medfilt1(theta,span);
            <span class="keyword">end</span>
            <span class="comment">% Sanity check:</span>
            <span class="keyword">if</span> length(y) ~= length(t)
                error(<span class="string">'y and t are of unequal lengths.'</span>)
            <span class="keyword">end</span>

            y = [0 diff(y)] ./ [0 diff(t)]; <span class="comment">% in degrees/sec</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [y,t] = get_acceleration(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">%   [y,t] = get_acceleration(obj,tid,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% Angular acceleration in degrees per second^2.</span>
            <span class="comment">%</span>
            <span class="comment">% tid: Trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Optional moving average smoothing window, in frames,</span>
            <span class="comment">%              **for position (theta) signal.** Acceleration is not</span>
            <span class="comment">%              separately smoothed. May want to smooth theta to</span>
            <span class="comment">%              eliminate noise due to whisker tracking artifacts.</span>
            <span class="comment">%               If not specified there is no smoothing. Should be</span>
            <span class="comment">%               an odd number (see 'help smooth').</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            <span class="comment">%             t = obj.time{ind};</span>

            <span class="keyword">if</span> nargin &gt; 2
                [velocity,t] = obj.get_velocity(tid,varargin{1});
            <span class="keyword">else</span>
                [velocity,t] = obj.get_velocity(tid);
            <span class="keyword">end</span>
            y = [0 diff(velocity)] ./ [0 diff(t)]; <span class="comment">% in degrees/sec</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plot_whisker_angle(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">%   plot_whisker_angle(obj,tid,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% tid: A single trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Optional plot color/symbol string specifier.</span>
            <span class="comment">%              Can be empty ([]) to allow access to varargin{2}.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{2}: Optional moving average smoothing window, in frames.</span>
            <span class="comment">%               If not specified there is no smoothing. Should be</span>
            <span class="comment">%               an odd number (see 'help smooth').</span>
            <span class="comment">%</span>
            <span class="comment">% If a *decrease* in slope in image coordinates cooresponds to</span>
            <span class="comment">% whisker protraction, then this function plots increasing</span>
            <span class="comment">% angles during protraction.</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin==2
                plotString = <span class="string">'k.-'</span>;
                [y,t] = obj.get_position(tid);
            <span class="keyword">elseif</span> nargin==3
                plotString = varargin{1};
                <span class="keyword">if</span> isempty(plotString)
                    plotString = <span class="string">'k.-'</span>;
                <span class="keyword">end</span>
                [y,t] = obj.get_position(tid);
            <span class="keyword">elseif</span> nargin==4
                plotString = varargin{1};
                <span class="keyword">if</span> isempty(plotString)
                    plotString = <span class="string">'k.-'</span>;
                <span class="keyword">end</span>
                span = varargin{2};
                [y,t] = obj.get_position(tid,span);
            <span class="keyword">end</span>

            plot(t,y,plotString);

            set(gca,<span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'box'</span>,<span class="string">'off'</span>)
            xlabel(<span class="string">'Sec'</span>)
        <span class="keyword">end</span>

        <span class="keyword">function</span> plot_whisker_curvature(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">%   plot_whisker_curvature(obj,tid,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Optional plot color/symbol string specifier.</span>
            <span class="comment">%</span>
            <span class="comment">%   Plots whisker curvature (units of pixels^(-1)) against</span>
            <span class="comment">%   time (in seconds).</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
            y = obj.kappa{ind};<span class="comment">% * obj.pxPerMm;</span>
            <span class="keyword">if</span> nargin &gt; 2
                plot(t,y, varargin{1});
            <span class="keyword">else</span>
                plot(t,y, <span class="string">'k.-'</span>);
            <span class="keyword">end</span>
            set(gca, <span class="string">'TickDir'</span>,<span class="string">'out'</span>,<span class="string">'box'</span>,<span class="string">'off'</span>)
            xlabel(<span class="string">'Sec'</span>)
        <span class="keyword">end</span>

        <span class="keyword">function</span> plot_whisker_curvatureDot(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">%   plot_whisker_curvatureDot(obj,tid,varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Optional plot color/symbol string specifier.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
            y = obj.curvatureDot(tid);
            <span class="keyword">if</span> nargin &gt; 2
                plot(t,y, varargin{1});
            <span class="keyword">else</span>
                plot(t,y, <span class="string">'k.-'</span>);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> obj = set_mask_from_points(obj,tid,x,y)
            <span class="comment">%</span>
            <span class="comment">% Sets obj.polyFitsMask in order</span>
            <span class="comment">% to create a mask defined by the points in x and y.</span>
            <span class="comment">%</span>
            <span class="comment">% tid: Trajectory ID. Can be a vector with multiple trajectory</span>
            <span class="comment">%       IDs. In this case all will be set to have same mask.</span>
            <span class="comment">%</span>
            <span class="comment">% x: Row vector of x coordinates to define mask.</span>
            <span class="comment">% y: Row vector of y coordinates to define mask.</span>
            <span class="comment">%</span>
            <span class="comment">% If N points are selected, mask will be the (N-1)-th</span>
            <span class="comment">% degree polynomial fit to the points for N &lt; 6. For N &gt;= 6</span>
            <span class="comment">% the polynomial will be 5-th degree.</span>
            <span class="comment">%</span>
            qnum = length(x);
            <span class="keyword">if</span> length(x) ~= length(y)
                error(<span class="string">'Inputs x and y must be of equal length.'</span>)
            <span class="keyword">end</span>

            <span class="comment">% Make x, y row vectors:</span>
            <span class="keyword">if</span> size(x,1) &gt; size(x,2)
                x = x';
            <span class="keyword">end</span>
            <span class="keyword">if</span> size(y,1) &gt; size(y,2)
                y = y';
            <span class="keyword">end</span>

            <span class="keyword">if</span> qnum &lt; 2
                error(<span class="string">'Must define at least 2 points.'</span>)
            <span class="keyword">elseif</span> qnum &lt; 6
                polyDegree = qnum-1;
            <span class="keyword">else</span>
                polyDegree = 5;
            <span class="keyword">end</span>

            q = (0:(qnum-1))./(qnum-1); <span class="comment">% [0,1]</span>

            <span class="comment">% polyfit() gives warnings that indicate that we don't need such a high degree</span>
            <span class="comment">% polynomials. Turn off.</span>
            warning(<span class="string">'off'</span>,<span class="string">'MATLAB:polyfit:RepeatedPointsOrRescale'</span>);
            px = polyfit(q,x,polyDegree);
            py = polyfit(q,y,polyDegree);
            warning(<span class="string">'on'</span>,<span class="string">'MATLAB:polyfit:RepeatedPointsOrRescale'</span>);

            <span class="keyword">if</span> isempty(obj.polyFitsMask)
                obj.polyFitsMask = cell(1,length(obj.trajectoryIDs));
            <span class="keyword">end</span>

            <span class="keyword">for</span> k=1:length(tid)
                ind = obj.trajectoryIDs==tid(k);
                <span class="keyword">if</span> max(ind) &lt; 1
                    error(<span class="string">'Trajectory ID was not found.'</span>)
                <span class="keyword">end</span>
                obj.polyFitsMask{ind} = {px,py};
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> obj = set_bar_offset(obj,dx,dy)
            <span class="comment">%</span>
            <span class="comment">% obj = set_bar_offset(obj,dx,dy)</span>
            <span class="comment">%</span>
            <span class="comment">% dx: Number of pixels to offset bar center in x.</span>
            <span class="comment">% dy: Number of pixels to offset bar center in y.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> length(dx) ~= 1 || length(dy) ~= 1
                error(<span class="string">'Arguments dx and dy must both be scaler.'</span>)
            <span class="keyword">end</span>

            obj.barPosOffset = [dx dy];

            <span class="comment">% Should also add capability to set different offsets for</span>
            <span class="comment">% different frames.</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plot_mask(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">% Plots the polynomial mask defined by obj.polyFitsMask.</span>
            <span class="comment">%</span>
            <span class="comment">% tid: A single trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Plot symbol string, e.g., 'k-'.  A string</span>
            <span class="comment">%               that can be given as an argument to plot().</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{2}: Tracked frame number, from 1 to the number of</span>
            <span class="comment">%        frames tracked. Not necessarily frame number from</span>
            <span class="comment">%        the original movie (unless all frames were tracked).</span>
            <span class="comment">%        If the mask is the same for all frames, this argument</span>
            <span class="comment">%        is ignored.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> isempty(obj.polyFitsMask)
                disp(<span class="string">'obj.polyFitsMask is empty; nothing to plot.'</span>)
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Trajectory ID was not found.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.polyFitsMask{ind})
                disp([<span class="string">'obj.polyFitsMask for tid '</span> int2str(tid) <span class="string">'is empty; nothing to plot.'</span>])
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> length(tid) &gt; 1
                error(<span class="string">'Only a single trajectory ID allowed.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 4
                error(<span class="string">'Too many input arguments.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 2
                plotString = varargin{1};
            <span class="keyword">else</span>
                plotString = <span class="string">'k-'</span>;
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 3
                frame = varargin{2};
                <span class="keyword">if</span> frame &gt; length(obj.time{ind})
                    error(<span class="string">'varargin{2}, the frame number, exceeds the number of tracked frames.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                frame = 1;
            <span class="keyword">end</span>

            px = obj.polyFitsMask{ind}{1};
            py = obj.polyFitsMask{ind}{2};

            <span class="keyword">if</span> size(px,1) &gt; 1
                px = px(frame,:);
                py = py(frame,:);
            <span class="keyword">end</span>

            q = linspace(0,1);

            x = polyval(px,q);
            y = polyval(py,q);

            plot(x,y,plotString,<span class="string">'LineWidth'</span>,2)
        <span class="keyword">end</span>

        <span class="keyword">function</span> [t,theta,kappa] = mean_theta_and_kappa(obj,tid,radial_window_theta,radial_window_kappa)
            <span class="comment">%</span>
            <span class="comment">%  [t,theta,kappa] = mean_theta_and_kappa(obj,tid,radial_window_theta,radial_window_kappa)</span>
            <span class="comment">%</span>
            <span class="comment">%   The whisker is parameterized as c(q) = (x(q),y(q)), where q has length(x)</span>
            <span class="comment">%   and is in [0,1].</span>
            <span class="comment">%</span>
            <span class="comment">% INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   tid: Whisker trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">%   radial_window_kappa: 2x1 vector giving arc length region of whisker to</span>
            <span class="comment">%   average over for mean kappa measurment, in format [startDistance stopDistance].</span>
            <span class="comment">%   Values are inclusive and in units of pixels. If empty ([]), averages over</span>
            <span class="comment">%   the whole whisker.</span>
            <span class="comment">%</span>
            <span class="comment">%   radial_window_theta: 2x1 vector giving arc length region of whisker to</span>
            <span class="comment">%   average over for mean kappa measurment, in format [startDistance stopDistance].</span>
            <span class="comment">%   Values are inclusive and in units of pixels. If empty ([]), averages over</span>
            <span class="comment">%   the whole whisker, which is not likely useful for theta.</span>
            <span class="comment">%</span>
            <span class="comment">%   For this function to work properly, object property 'radialDirection'</span>
            <span class="comment">%   must be correctly set.  See help Whisker.WhiskerTrial.set_radialDirection.</span>
            <span class="comment">%</span>
            <span class="comment">% RETURNS:</span>
            <span class="comment">%</span>
            <span class="comment">%   t:  Time in seconds corresponding to each frame.</span>
            <span class="comment">%</span>
            <span class="comment">%   theta: Angle of the line tangent to the whisker (i.e., to c(q)), averaged over</span>
            <span class="comment">%           radial distances (arc length) between and including radial_window_theta(1)</span>
            <span class="comment">%           and radial_window_theta(2).</span>
            <span class="comment">%</span>
            <span class="comment">%   kappa:  Signed curvature averaged over radials distances (arc length) between and including</span>
            <span class="comment">%           radial_window_kappa(1) and radial_window_kappa(2), for each frame.</span>
            <span class="comment">%           Units of 1/pixels. Abs(kappa(q)) is 1/X where X is</span>
            <span class="comment">%           the radius in pixels of the osculating circle at c(q).</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>

            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);

            <span class="keyword">if</span> isempty(radial_window_kappa)
                kappa = cellfun(@mean, KAPPA);
            <span class="keyword">else</span>
                <span class="comment">%                 kappa = cellfun(@(x,y) mean(x(y &gt;= radial_window_kappa(1) &amp; y &lt;= radial_window_kappa(2))),KAPPA,R);</span>
                nframes = length(R);
                kappa = nan(1,nframes);
                <span class="keyword">for</span> k=1:length(R)
                    <span class="keyword">if</span> ~isnan(R{k}(1))
                        kappa(k) = mean(KAPPA{k}( R{k} &gt;= radial_window_kappa(1) &amp; R{k} &lt;= radial_window_kappa(2) ));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>


            <span class="keyword">if</span> isempty(radial_window_theta)
                theta = cellfun(@mean, THETA);
            <span class="keyword">else</span>
                <span class="comment">%                 theta = cellfun(@(x,y) mean(x(y &gt;= radial_window_theta(1) &amp; y &lt;= radial_window_theta(2))),THETA,R);</span>
                nframes = length(R);
                theta = nan(1,nframes);
                <span class="keyword">for</span> k=1:length(R)
                    <span class="keyword">if</span> ~isnan(R{k}(1))
                        theta(k) = mean(THETA{k}( R{k} &gt;= radial_window_theta(1) &amp; R{k} &lt;= radial_window_theta(2) ));
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            t = obj.get_time(tid);

            <span class="comment">% Interpolate to fill missing (NaN) values, arising for instance if there</span>
            <span class="comment">% weren't enough pixels to do curve fitting. NaN also arise if obj.maskTreatment</span>
            <span class="comment">% is set to 'maskNaN'.</span>
            missing = isnan(kappa);
            <span class="keyword">if</span> sum(missing)==length(kappa)
                error(<span class="string">'Less than 2 non-NaN values for mean kappa timeseries. May be a bad mask, that no whiskers cross.'</span>)
            <span class="keyword">end</span>
            kappa = interp1(t(~missing),kappa(~missing),t,<span class="string">'linear'</span>,<span class="string">'extrap'</span>);

            missing = isnan(theta);
            <span class="keyword">if</span> sum(missing)==length(theta)
                error(<span class="string">'Less than 2 non-NaN values for mean theta timeseries. May be a bad mask, that no whiskers cross.'</span>)
            <span class="keyword">end</span>
            theta = interp1(t(~missing),theta(~missing),t,<span class="string">'linear'</span>,<span class="string">'extrap'</span>);
        <span class="keyword">end</span>

<span class="comment">%         function [y,t] = get_follicle_arc_length_position(obj,tid)</span>
<span class="comment">%             %</span>
<span class="comment">%             % [y,t] = get_follicle_arc_length_position(obj,tid)</span>
<span class="comment">%             %</span>
<span class="comment">%             % Fits polynomials to the the follicle x and y coordinates, parameterizing</span>
<span class="comment">%             % the path they take along the face as c(q) = (x(q),y(q)), where q is in [0,1].</span>
<span class="comment">%             % Arc length at each point along this path is then computed. For each frame</span>
<span class="comment">%             % the closest point on the curve to the follicle is determined. The arc-length</span>
<span class="comment">%             % location of this point is returned in r.</span>
<span class="comment">%             %</span>
<span class="comment">%             % obj.follicleCoordsX and obj.follicleCoordsY must be non-empty (i.e.</span>
<span class="comment">%             % obj.recompute_cached_follicle_coords() must have been called.</span>
<span class="comment">%             %</span>
<span class="comment">%             %</span>
<span class="comment">%             %</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%</span>
<span class="comment">%         end</span>

        <span class="keyword">function</span> [R,THETA,KAPPA,varargout] = arc_length_theta_and_kappa(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">% [R,THETA,KAPPA] = arc_length_theta_and_kappa(obj,tid)</span>
            <span class="comment">% [R,THETA,KAPPA,Y,X] = arc_length_theta_and_kappa(obj,tid)</span>
            <span class="comment">% [R,THETA,KAPPA] = arc_length_theta_and_kappa(obj,tid,npoints)</span>
            <span class="comment">%</span>
            <span class="comment">%   The whisker is parameterized as c(q) = (x(q),y(q)), where q</span>
            <span class="comment">%   is in [0,1].</span>
            <span class="comment">%</span>
            <span class="comment">%   For this function to work properly, object properties 'faceSideInImage'</span>
            <span class="comment">%   and 'imagePixelDimsXY' must be correctly set.</span>
            <span class="comment">%</span>
            <span class="comment">% INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   tid: Whisker trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">%   varargin{1}: Optional, integer giving number of points (values of q) to</span>
            <span class="comment">%        use in reconstructing each whisker. Default is 100 points.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% RETURNS:</span>
            <span class="comment">%</span>
            <span class="comment">%   R:  A cell array where each element is the arc length, computed moving outward from</span>
            <span class="comment">%       whisker follicle along the whisker for a single frame. Units of pixels.</span>
            <span class="comment">%</span>
            <span class="comment">%   THETA: A cell array where each element theta is the angle of the line tangent to the</span>
            <span class="comment">%           whisker (i.e., to c(q)) at each value of q. In</span>
            <span class="comment">%           degrees.</span>
            <span class="comment">%</span>
            <span class="comment">%   KAPPA: A cell array where each element kappa is the signed curvature at each point</span>
            <span class="comment">%           on the whisker (i.e., for each value of q). Units of 1/pixels. Abs(kappa(q)) is 1/X where X is</span>
            <span class="comment">%           the radius in pixels of the osculating circle at c(q).</span>
            <span class="comment">%</span>
            <span class="comment">%   Optionally also:</span>
            <span class="comment">%</span>
            <span class="comment">%   X,Y: Cell arrays containing the x and y image (pixel) coordinates corresponding to the</span>
            <span class="comment">%        values in R, THETA, and KAPPA.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   kappa(q) = (x'y'' - y'x'') / (x'^2 + y'^2)^(3/2)</span>
            <span class="comment">%   theta(q) = atand(y'/x')</span>
            <span class="comment">%   arc_length(q) = cumsum(sqrt(x'^2 + y'^2))</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> nargin &lt; 3
                npoints = 100;
            <span class="keyword">else</span>
                npoints = varargin{1};
                <span class="keyword">if</span> isempty(npoints)
                    npoints = 100;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            nframes = size(obj.polyFits{ind}{1},1);

            <span class="keyword">if</span> isempty(obj.polyFits)
                error(<span class="string">'obj.polyFits is empty.'</span>)
            <span class="keyword">end</span>

            R = cell(1,nframes);
            THETA = cell(1,nframes);
            KAPPA = cell(1,nframes);

            <span class="keyword">if</span> nargout&gt;3
                X = cell(1,nframes);
                Y = cell(1,nframes);
            <span class="keyword">end</span>

            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};

            q = linspace(0,1,npoints);

            <span class="keyword">for</span> k=1:nframes

                px = fittedX(k,:);
                py = fittedY(k,:);

                pxDot = polyder(px);
                pxDoubleDot = polyder(pxDot);

                pyDot = polyder(py);
                pyDoubleDot = polyder(pyDot);

                xDot = polyval(pxDot,q);
                xDoubleDot = polyval(pxDoubleDot,q);

                yDot = polyval(pyDot,q);
                yDoubleDot = polyval(pyDoubleDot,q);

                dq = [0 diff(q)];

                <span class="comment">% Arc length as a function of q, after integration below:</span>
                R{k} = cumsum(sqrt(xDot.^2 + yDot.^2) .* dq); <span class="comment">% arc length segments, in pixels, times dq.</span>


                <span class="comment">% Angle (in degrees) as a function of q:</span>
                <span class="comment">% Protraction means theta is increasing.</span>
                <span class="comment">% Theta is 0 when perpendicular to the midline of the mouse.</span>
                <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>)
                    THETA{k} = atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>)
                    THETA{k} = -atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>)
                    THETA{k} = atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>)
                    THETA{k} = -atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>)
                    THETA{k} = atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>)
                    THETA{k} = -atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>)
                    THETA{k} = -atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>)
                    THETA{k} = atand(xDot ./ yDot);
                <span class="keyword">else</span>
                    error(<span class="string">'Invalid value of property ''faceSideInImage'' or ''protractionDirection'''</span>)
                <span class="keyword">end</span>


                <span class="comment">% Signed curvature as a function of q:</span>
                KAPPA{k} = (xDot.*yDoubleDot - yDot.*xDoubleDot) ./ ((xDot.^2 + yDot.^2).^(3/2)); <span class="comment">% SIGNED CURVATURE, in 1/pixels.</span>
                <span class="comment">%                 KAPPA{k} = abs(xDot.*yDoubleDot - yDot.*xDoubleDot) ./ ((xDot.^2 + yDot.^2).^(3/2)); % CURVATURE, in 1/pixels.</span>

                <span class="keyword">if</span> nargout&gt;3
                    X{k} = polyval(px,q);
                    Y{k} = polyval(py,q);
                    varargout{1} = Y;
                    varargout{2} = X;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Apply any mask:</span>
            <span class="keyword">if</span> iscell(obj.maskTreatment)
                <span class="keyword">if</span> length(obj.maskTreatment) ~= length(obj.trajectoryIDs)
                    error(<span class="string">'obj.maskTreatment and obj.trajectoryIDs must have the same length and matching entries.'</span>)
                <span class="keyword">end</span>
                mask_treatment = obj.maskTreatment{ind};
            <span class="keyword">else</span>
                mask_treatment = obj.maskTreatment;
            <span class="keyword">end</span>

            <span class="keyword">if</span> strcmp(mask_treatment,<span class="string">'none'</span>)
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            <span class="comment">% If there is a polynomial mask specified (see documentation for</span>
            <span class="comment">% object property 'polyFitsMask') and varargin{1} is given, subtract from each element of</span>
            <span class="comment">% R the radial distance at the intersection, if any, of the fitted</span>
            <span class="comment">% whisker and the polynomial mask.</span>
            <span class="keyword">if</span> isempty(obj.polyFitsMask)
                <span class="keyword">return</span>
            <span class="keyword">else</span>
                pm = obj.polyFitsMask{ind};
                <span class="keyword">if</span> isempty(pm)
                    <span class="keyword">return</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            fittedXMask = obj.polyFitsMask{ind}{1};
            fittedYMask = obj.polyFitsMask{ind}{2};

            q = linspace(0,1,npoints);

            <span class="keyword">for</span> k=1:nframes

                px = fittedX(k,:);
                py = fittedY(k,:);

                <span class="keyword">if</span> size(fittedXMask,1) &gt; 1
                    pxm = fittedXMask(k,:);
                    pym = fittedYMask(k,:);
                <span class="keyword">else</span>
                    pxm = fittedXMask;
                    pym = fittedYMask;
                <span class="keyword">end</span>

                C1 = [polyval(px,q); polyval(py,q)];
                C2 = [polyval(pxm,q); polyval(pym,q)];

                P = Whisker.InterX(C1,C2); <span class="comment">% Find points where whisker and mask curves intersect. Slower but more</span>
                                           <span class="comment">% accurate version that isn't limited in resolution by the number of</span>
                                           <span class="comment">% points whisker and mask are evaluated at.</span>
                <span class="keyword">if</span> size(P,2) &gt; 1   <span class="comment">% Don't need for faster version, which handles this.</span>
                    disp(<span class="string">'Found more than 1 intersection of whisker and mask curves; using only first.'</span>)
                    P = P(:,1);
                <span class="keyword">end</span>

<span class="comment">%                 P = Whisker.InterXFast(C1,C2); % Find points where whisker and mask curves intersect. Much faster version</span>
<span class="comment">%                                                 % that is limited in resolution by the number of</span>
<span class="comment">%                                                 % points whisker and mask are evaluated at (i.e., by number of points in q).</span>

                <span class="keyword">if</span> isempty(P)
                    <span class="keyword">if</span> strcmp(mask_treatment,<span class="string">'maskNaN'</span>)
                        R{k} = nan(size(R{k}));
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="comment">% Find at what q the whisker is at (P(1),P(2)), i.e., q s.t. x(q)=P(1),y(q)=P(2).</span>
                    <span class="comment">% Doesn't match exactly (maybe due to roundoff error), so find closest.</span>
                    C = C1 - repmat(P,[1 size(C1,2)]);
                    err = sqrt(C(1,:).^2 + C(2,:).^2);
                    ind2 = err==min(err);
                    R{k} = R{k} - R{k}(ind2);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [R,THETA,varargout] = arc_length_and_theta(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">% POINT OF THIS IS THAT IT'S FASTER THAN arc_length_theta_and_kappa when</span>
            <span class="comment">% KAPPA IS NOT NEEDED.****</span>
            <span class="comment">%</span>
            <span class="comment">% [R,THETA] = arc_length_theta_and_kappa(obj,tid)</span>
            <span class="comment">% [R,THETA,Y,X] = arc_length_theta_and_kappa(obj,tid)</span>
            <span class="comment">% [R,THETA] = arc_length_theta_and_kappa(obj,tid,npoints)</span>
            <span class="comment">%</span>
            <span class="comment">%   The whisker is parameterized as c(q) = (x(q),y(q)), where q</span>
            <span class="comment">%   is in [0,1].</span>
            <span class="comment">%</span>
            <span class="comment">%   For this function to work properly, object properties 'faceSideInImage'</span>
            <span class="comment">%   and 'imagePixelDimsXY' must be correctly set.</span>
            <span class="comment">%</span>
            <span class="comment">% INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   tid: Whisker trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">%   varargin{1}: Optional, integer giving number of points (values of q) to</span>
            <span class="comment">%        use in reconstructing each whisker. Default is 100 points.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% RETURNS:</span>
            <span class="comment">%</span>
            <span class="comment">%   R:  A cell array where each element is the arc length, computed moving outward from</span>
            <span class="comment">%       whisker follicle along the whisker for a single frame. Units of pixels.</span>
            <span class="comment">%</span>
            <span class="comment">%   THETA: A cell array where each element theta is the angle of the line tangent to the</span>
            <span class="comment">%           whisker (i.e., to c(q)) at each value of q. In</span>
            <span class="comment">%           degrees.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   Optionally also:</span>
            <span class="comment">%</span>
            <span class="comment">%   X,Y: Cell arrays containing the x and y image (pixel) coordinates corresponding to the</span>
            <span class="comment">%        values in R, THETA, and KAPPA.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   kappa(q) = (x'y'' - y'x'') / (x'^2 + y'^2)^(3/2)</span>
            <span class="comment">%   theta(q) = atand(y'/x')</span>
            <span class="comment">%   arc_length(q) = cumsum(sqrt(x'^2 + y'^2))</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> nargin &lt; 3
                npoints = 100;
            <span class="keyword">else</span>
                npoints = varargin{1};
                <span class="keyword">if</span> isempty(npoints)
                    npoints = 100;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            nframes = size(obj.polyFits{ind}{1},1);

            <span class="keyword">if</span> isempty(obj.polyFits)
                error(<span class="string">'obj.polyFits is empty.'</span>)
            <span class="keyword">end</span>

            R = cell(1,nframes);
            THETA = cell(1,nframes);

            <span class="keyword">if</span> nargout&gt;3
                X = cell(1,nframes);
                Y = cell(1,nframes);
            <span class="keyword">end</span>

            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};

            q = linspace(0,1,npoints);

            <span class="keyword">for</span> k=1:nframes

                px = fittedX(k,:);
                py = fittedY(k,:);

                pxDot = polyder(px);

                pyDot = polyder(py);

                xDot = polyval(pxDot,q);

                yDot = polyval(pyDot,q);

                dq = [0 diff(q)];

                <span class="comment">% Arc length as a function of q, after integration below:</span>
                R{k} = cumsum(sqrt(xDot.^2 + yDot.^2) .* dq); <span class="comment">% arc length segments, in pixels, times dq.</span>


                <span class="comment">% Angle (in degrees) as a function of q:</span>
                <span class="comment">% Protraction means theta is increasing.</span>
                <span class="comment">% Theta is 0 when perpendicular to the midline of the mouse.</span>
                <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>)
                    THETA{k} = atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>)
                    THETA{k} = -atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>)
                    THETA{k} = atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>)
                    THETA{k} = -atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>)
                    THETA{k} = atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>)
                    THETA{k} = -atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>)
                    THETA{k} = -atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>)
                    THETA{k} = atand(xDot ./ yDot);
                <span class="keyword">else</span>
                    error(<span class="string">'Invalid value of property ''faceSideInImage'' or ''protractionDirection'''</span>)
                <span class="keyword">end</span>

                <span class="keyword">if</span> nargout&gt;3
                    X{k} = polyval(px,q);
                    Y{k} = polyval(py,q);
                    varargout{1} = Y;
                    varargout{2} = X;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Apply any mask:</span>
            <span class="keyword">if</span> iscell(obj.maskTreatment)
                <span class="keyword">if</span> length(obj.maskTreatment) ~= length(obj.trajectoryIDs)
                    error(<span class="string">'obj.maskTreatment and obj.trajectoryIDs must have the same length and matching entries.'</span>)
                <span class="keyword">end</span>
                mask_treatment = obj.maskTreatment{ind};
            <span class="keyword">else</span>
                mask_treatment = obj.maskTreatment;
            <span class="keyword">end</span>

            <span class="keyword">if</span> strcmp(mask_treatment,<span class="string">'none'</span>)
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            <span class="comment">% If there is a polynomial mask specified (see documentation for</span>
            <span class="comment">% object property 'polyFitsMask') and varargin{1} is given, subtract from each element of</span>
            <span class="comment">% R the radial distance at the intersection, if any, of the fitted</span>
            <span class="comment">% whisker and the polynomial mask.</span>
            <span class="keyword">if</span> isempty(obj.polyFitsMask)
                <span class="keyword">return</span>
            <span class="keyword">else</span>
                pm = obj.polyFitsMask{ind};
                <span class="keyword">if</span> isempty(pm)
                    <span class="keyword">return</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            fittedXMask = obj.polyFitsMask{ind}{1};
            fittedYMask = obj.polyFitsMask{ind}{2};

            q = linspace(0,1,npoints);

            <span class="keyword">for</span> k=1:nframes

                px = fittedX(k,:);
                py = fittedY(k,:);

                <span class="keyword">if</span> size(fittedXMask,1) &gt; 1
                    pxm = fittedXMask(k,:);
                    pym = fittedYMask(k,:);
                <span class="keyword">else</span>
                    pxm = fittedXMask;
                    pym = fittedYMask;
                <span class="keyword">end</span>

                C1 = [polyval(px,q); polyval(py,q)];
                C2 = [polyval(pxm,q); polyval(pym,q)];

                P = Whisker.InterX(C1,C2); <span class="comment">% Find points where whisker and mask curves intersect. Slower but more</span>
                                           <span class="comment">% accurate version that isn't limited in resolution by the number of</span>
                                           <span class="comment">% points whisker and mask are evaluated at.</span>
                <span class="keyword">if</span> size(P,2) &gt; 1   <span class="comment">% Don't need for faster version, which handles this.</span>
                    disp(<span class="string">'Found more than 1 intersection of whisker and mask curves; using only first.'</span>)
                    P = P(:,1);
                <span class="keyword">end</span>

<span class="comment">%                 P = Whisker.InterXFast(C1,C2); % Find points where whisker and mask curves intersect. Much faster version</span>
<span class="comment">%                                                 % that is limited in resolution by the number of</span>
<span class="comment">%                                                 % points whisker and mask are evaluated at (i.e., by number of points in q).</span>

                <span class="keyword">if</span> isempty(P)
                    <span class="keyword">if</span> strcmp(mask_treatment,<span class="string">'maskNaN'</span>)
                        R{k} = nan(size(R{k}));
                    <span class="keyword">end</span>
                <span class="keyword">else</span>
                    <span class="comment">% Find at what q the whisker is at (P(1),P(2)), i.e., q s.t. x(q)=P(1),y(q)=P(2).</span>
                    <span class="comment">% Doesn't match exactly (maybe due to roundoff error), so find closest.</span>
                    C = C1 - repmat(P,[1 size(C1,2)]);
                    err = sqrt(C(1,:).^2 + C(2,:).^2);
                    ind2 = err==min(err);
                    R{k} = R{k} - R{k}(ind2);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [R,THETA,KAPPA,varargout] = arc_length_theta_and_kappa_in_roi(obj,tid,varargin)
            <span class="comment">%</span>
            <span class="comment">% [R,THETA,KAPPA] = arc_length_theta_and_kappa_in_roi(obj,tid)</span>
            <span class="comment">% [R,THETA,KAPPA,Y,X] = arc_length_theta_and_kappa_in_roi(obj,tid)</span>
            <span class="comment">% [R,THETA,KAPPA] = arc_length_theta_and_kappa_in_roi(obj,tid,npoints)</span>
            <span class="comment">%</span>
            <span class="comment">%   The whisker is parameterized as c(q) = (x(q),y(q)), where q</span>
            <span class="comment">%   is in [0,1]. However, here we deal with a second representation of the</span>
            <span class="comment">%   whisker, where polynomials were fitted over a constant region of arc-length,</span>
            <span class="comment">%   [q0,q1], q0,q1 both within [0,1].</span>
            <span class="comment">%</span>
            <span class="comment">%   For this function to work properly, object properties 'faceSideInImage'</span>
            <span class="comment">%   and 'imagePixelDimsXY' must be correctly set.</span>
            <span class="comment">%</span>
            <span class="comment">% INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%   tid: Whisker trajectory ID.</span>
            <span class="comment">%</span>
            <span class="comment">%   varargin{1}: Optional, integer giving number of points (values of q) to</span>
            <span class="comment">%        use in reconstructing each whisker. Default is 100 points.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% RETURNS:</span>
            <span class="comment">%</span>
            <span class="comment">%   R:  A cell array where each element is the arc length, computed moving outward from</span>
            <span class="comment">%       whisker follicle along the whisker for a single frame, but only those values</span>
            <span class="comment">%       falling within the ROI. Units of pixels.</span>
            <span class="comment">%</span>
            <span class="comment">%   THETA: A cell array where each element theta is the angle of the line tangent to the</span>
            <span class="comment">%           whisker (i.e., to c(q)) at each value of q in the ROI. In</span>
            <span class="comment">%           degrees.</span>
            <span class="comment">%</span>
            <span class="comment">%   KAPPA: A cell array where each element kappa is the signed curvature at each point</span>
            <span class="comment">%           on the whisker within the ROI. Units of 1/pixels. Abs(kappa(q)) is 1/X where X is</span>
            <span class="comment">%           the radius in pixels of the osculating circle at c(q). Uses the secondary polynomials</span>
            <span class="comment">%           fitted within the ROI.</span>
            <span class="comment">%</span>
            <span class="comment">%   Optionally also:</span>
            <span class="comment">%</span>
            <span class="comment">%   X,Y: Cell arrays containing the x and y image (pixel) coordinates corresponding to the</span>
            <span class="comment">%        values in R, THETA, and KAPPA.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> nargin &lt; 3
                npoints = 100;
            <span class="keyword">else</span>
                npoints = varargin{1};
                <span class="keyword">if</span> isempty(npoints)
                    npoints = 100;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            nframes = size(obj.polyFitsROI{ind}{1},1);

            <span class="keyword">if</span> isempty(obj.polyFitsROI)
                error(<span class="string">'obj.polyFitsROI is empty.'</span>)
            <span class="keyword">end</span>

            R = cell(1,nframes);
            THETA = cell(1,nframes);
            KAPPA = cell(1,nframes);

            <span class="keyword">if</span> nargout&gt;3
                X = cell(1,nframes);
                Y = cell(1,nframes);
            <span class="keyword">end</span>

            fittedX = obj.polyFitsROI{ind}{1};
            fittedY = obj.polyFitsROI{ind}{2};
            fittedQ = obj.polyFitsROI{ind}{3};

            <span class="keyword">for</span> k=1:nframes

                px = fittedX(k,:);
                py = fittedY(k,:);
                pq = fittedQ(k,:);

                q = linspace(pq(1),pq(2),npoints);

                pxDot = polyder(px);
                pxDoubleDot = polyder(pxDot);

                pyDot = polyder(py);
                pyDoubleDot = polyder(pyDot);

                xDot = polyval(pxDot,q);
                xDoubleDot = polyval(pxDoubleDot,q);

                yDot = polyval(pyDot,q);
                yDoubleDot = polyval(pyDoubleDot,q);

                dq = [0 diff(q)];

                <span class="comment">% Arc length as a function of q, after integration below:</span>
                R{k} = cumsum(sqrt(xDot.^2 + yDot.^2) .* dq); <span class="comment">% arc length segments, in pixels, times dq.</span>


                R{k} = R{k} + pq(3); <span class="comment">% Add the whole-whisker arc-length of the first point in the ROI to make this quantity the arc-length</span>
                                     <span class="comment">% measured over the whole fitted whisker, not just arc-length over the ROI.</span>
                                     <span class="comment">% Note that pq(3) already accounts for mask, so do not need to do so in this method.</span>


                <span class="comment">% Angle (in degrees) as a function of q:</span>
                <span class="comment">% Protraction means theta is increasing.</span>
                <span class="comment">% Theta is 0 when perpendicular to the midline of the mouse.</span>
                <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>)
                    THETA{k} = atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>)
                    THETA{k} = -atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>)
                    THETA{k} = atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>)
                    THETA{k} = -atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'upward'</span>)
                    THETA{k} = atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'downward'</span>)
                    THETA{k} = -atand(yDot ./ xDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'rightward'</span>)
                    THETA{k} = -atand(xDot ./ yDot);
                <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>) &amp;&amp; strcmp(obj.protractionDirection,<span class="string">'leftward'</span>)
                    THETA{k} = atand(xDot ./ yDot);
                <span class="keyword">else</span>
                    error(<span class="string">'Invalid value of property ''faceSideInImage'' or ''protractionDirection'''</span>)
                <span class="keyword">end</span>

                <span class="comment">% Signed curvature as a function of q:</span>
                KAPPA{k} = (xDot.*yDoubleDot - yDot.*xDoubleDot) ./ ((xDot.^2 + yDot.^2).^(3/2)); <span class="comment">% SIGNED CURVATURE, in 1/pixels.</span>
                <span class="comment">%                 KAPPA{k} = abs(xDot.*yDoubleDot - yDot.*xDoubleDot) ./ ((xDot.^2 + yDot.^2).^(3/2)); % CURVATURE, in 1/pixels.</span>

                <span class="keyword">if</span> nargout&gt;3
                    X{k} = polyval(px,q);
                    Y{k} = polyval(py,q);
                    varargout{1} = Y;
                    varargout{2} = X;
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="comment">% Do not need to apply any mask, because pq(3) above already accounts for mask.</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> t = get_time(obj,tid)
            <span class="comment">%</span>
            <span class="comment">%   t = get_time(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%   INPUTS:</span>
            <span class="comment">%       tid:  Trajectory ID (as an integer) or whisker name (as a string).</span>
            <span class="comment">%</span>
            <span class="comment">%   OUTPUTS:</span>
            <span class="comment">%       t: time in seconds for each sample in this WhiskerSignalTrial</span>
            <span class="comment">%       for given trajectory ID or whisker name.</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> isnumeric(tid) <span class="comment">% Trajectory ID specified.</span>
                ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">elseif</span> ischar(tid) <span class="comment">% Whisker name specified.</span>
                ind = strmatch(tid,obj.whiskerNames,<span class="string">'exact'</span>);
            <span class="keyword">else</span>
                error(<span class="string">'Invalid type for argument ''tid''.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
        <span class="keyword">end</span>

        <span class="keyword">function</span> [rNearest,thetaNearest,kappaNearest,yNearest,xNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid,proximity_threshold)
            <span class="comment">%</span>
            <span class="comment">% USAGE:</span>
            <span class="comment">%   [rNearest,thetaNearest,kappaNearest,yNearest,xNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid)</span>
            <span class="comment">%   [rNearest,thetaNearest,kappaNearest,yNearest,xNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid,proximity_threshold)</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   INPUTS:</span>
            <span class="comment">%       tid:  Trajectory ID (as an integer) or whisker name (as a string).</span>
            <span class="comment">%       proximity_threshold:  Optional argument giving distance from nearest point on whisker</span>
            <span class="comment">%               to bar center, in units of bar radius, beyond which</span>
            <span class="comment">%               the whisker will be extrapolated along the last theta in</span>
            <span class="comment">%               order to determine distance between whisker and bar.</span>
            <span class="comment">%</span>
            <span class="comment">%   OUTPUTS:</span>
            <span class="comment">%       rNearest: Arc-length (radial) distance along whisker to point nearest</span>
            <span class="comment">%                 center of the bar. Units of pixels.</span>
            <span class="comment">%       thetaNearest: Theta at rNearest.</span>
            <span class="comment">%       kappaNearest: Kappa at rNearest.</span>
            <span class="comment">%       YNearest: Image-coordinate Y value at rNearest. This estimates point of contact. In pixels.</span>
            <span class="comment">%       XNearest: Image-coordinate X value at rNearest. This estimates point of contact. In pixels.</span>
            <span class="comment">%       dist: Distance from bar center to nearest point on whisker. Units of pixels.</span>
            <span class="comment">%       t: The corresponding times of each observation.</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> isnumeric(tid) <span class="comment">% Trajectory ID specified.</span>
                ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">elseif</span> ischar(tid) <span class="comment">% Whisker name specified.</span>
                ind = strmatch(tid,obj.whiskerNames,<span class="string">'exact'</span>);
            <span class="keyword">else</span>
                error(<span class="string">'Invalid type for argument ''tid''.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &lt; 3
                proximity_threshold = -1;
            <span class="keyword">end</span>

            t = obj.time{ind};
            f = t / obj.framePeriodInSec;
            nframes = length(f);

            <span class="comment">% Add any offset to the tracked bar position:</span>
            <span class="keyword">if</span> isempty(obj.barPosOffset);
                bp = obj.barPosClean;
            <span class="keyword">else</span>
                bp = obj.barPosClean;
                <span class="keyword">if</span> size(obj.barPosOffset,1)==1
                    bp = bp + repmat([0 obj.barPosOffset],size(bp,1),1);
                <span class="keyword">elseif</span> size(obj.barPosOffset,1)==size(bp,1) &amp;&amp; size(obj.barPosOffset,2)==2
                    bp = bp + obj.barPosOffset;
                <span class="keyword">else</span>
                    error(<span class="string">'Size of obj.barPosOffset is not valid; must be either 1 x 2 or nframes x 2.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            bar_f = bp(:,1);
            bar_x = bp(:,2);
            bar_y = bp(:,3);

            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);

            rNearest = zeros(1,nframes);
            thetaNearest = zeros(1,nframes);
            kappaNearest = zeros(1,nframes);
            dist = zeros(1,nframes);
            xNearest = zeros(1,nframes);
            yNearest = zeros(1,nframes);

            q = linspace(0,1); <span class="comment">% This must be same as that used in obj.arc_length_theta_and_kappa().</span>

            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};

            <span class="keyword">for</span> k=1:nframes
                <span class="comment">%                 disp(['Computing nearest-point values for frame=' int2str(k)])</span>
                px = fittedX(k,:);
                py = fittedY(k,:);

                x = polyval(px,q);
                y = polyval(py,q);

<span class="comment">%                 ind = bar_f == f(k);</span>
                ind = abs(bar_f-f(k)) &lt; 1e-12;

                <span class="keyword">if</span> ~any(ind) || any(isnan(x)) || any(isnan(y))
                    rNearest(k) = NaN;
                    thetaNearest(k) = NaN;
                    kappaNearest(k) = NaN;
                    xNearest(k) = NaN;
                    yNearest(k) = NaN;
                    dist(k) = NaN;
                    <span class="keyword">continue</span>
                <span class="keyword">end</span>
                bx = bar_x(ind); <span class="comment">% center of bar -- offset if appropriate</span>
                by = bar_y(ind);

                <span class="comment">% Find closest point iteratively:</span>
                npoints = length(x);
                d = zeros(npoints,1);
                <span class="keyword">for</span> j=1:npoints
                    d(j) = sqrt((x(j)-bx)^2 + (y(j)-by)^2);
                <span class="keyword">end</span>
                ind = find(d==min(d));
                ind = ind(1); <span class="comment">% in case there are points of equal distance, take first; Later this should be first along arc-length of whisker*****</span>

                <span class="keyword">if</span> proximity_threshold &lt; 0
                    dist(k) = d(ind) - obj.barRadius;
                <span class="keyword">elseif</span> d(ind) &lt; obj.barRadius*proximity_threshold
                    thetaW = THETA{k}(ind); <span class="comment">% Angle of whisker at last point on whisker.</span>

                    <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>)
                        a = [tand(thetaW) 1]; <span class="comment">% Vector extending from last point on whisker along angle of whisker.</span>
                    <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>)  <span class="comment">% DHO, 12oct11: Don't have test data for these conditions, remains untested</span>
                        a = [tand(thetaW) -1]; <span class="comment">% Vector extending from last point on whisker along angle of whisker.</span>
                    <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>)
                        a = [1 tand(thetaW)]; <span class="comment">% Vector extending from last point on whisker along angle of whisker.</span>
                    <span class="keyword">else</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) <span class="comment">% DHO, 12oct11: Don't have test data for these conditions, remains untested</span>
                        a = [-1 tand(thetaW)]; <span class="comment">% Vector extending from last point on whisker along angle of whisker.</span>
                    <span class="keyword">end</span>

                    b = [bx-x(ind) by-y(ind)]; <span class="comment">% Vector from last point on whisker to pole center.</span>
                    a_norm = norm(a);
                    b_norm = norm(b);
                    thetaWP = abs(acosd(dot(a,b)/(a_norm*b_norm))); <span class="comment">% Angle between whisker and pole. Don't care about sign, so take absolute value.</span>

                    dist(k) = b_norm*sind(thetaWP);
                    dist(k) = dist(k) - obj.barRadius;
                <span class="keyword">else</span>
                    dist(k) = d(ind) - obj.barRadius;
                <span class="keyword">end</span>


                rNearest(k) = R{k}(ind);
                thetaNearest(k) = THETA{k}(ind);
                kappaNearest(k) = KAPPA{k}(ind);
                xNearest(k) = x(ind);
                yNearest(k) = y(ind);
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [theta0,kappa0,t] = get_theta_kappa_at_base(obj,tid)
            <span class="comment">%</span>
            <span class="comment">%   [theta0,kappa0,t] = get_theta_kappa_at_base(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%   INPUTS:</span>
            <span class="comment">%       tid:  Trajectory ID (as an integer) or whisker name (as a string).</span>
            <span class="comment">%</span>
            <span class="comment">%   OUTPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%       theta0: Theta at radial distance 0. Radial distance 0 is determined</span>
            <span class="comment">%                     in part by the mask, if present. In degrees.</span>
            <span class="comment">%</span>
            <span class="comment">%       kappa0: kappa at radial distance 0. Radial distance 0 is determined</span>
            <span class="comment">%                     in part by the mask, if present. Units of 1/pixels.</span>
            <span class="comment">%</span>
            <span class="comment">%       t: The corresponding times of each observation.</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> isnumeric(tid) <span class="comment">% Trajectory ID specified.</span>
                ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">elseif</span> ischar(tid) <span class="comment">% Whisker name specified.</span>
                ind = strmatch(tid,obj.whiskerNames,<span class="string">'exact'</span>);
            <span class="keyword">else</span>
                error(<span class="string">'Invalid type for argument ''tid''.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};

            <span class="keyword">if</span> all(isnan(t))
                disp([<span class="string">'Nothing tracked for tid '</span> int2str(tid) <span class="string">'; setting theta0,kappa0,t to NaN.'</span>])
                theta0 = NaN;
                kappa0 = NaN;
                t = NaN;
                <span class="keyword">return</span>
            <span class="keyword">end</span>


            f = t / obj.framePeriodInSec;
            nframes = length(f);

            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);

            theta0 = zeros(1,nframes);
            kappa0 = zeros(1,nframes);

            <span class="keyword">for</span> k=1:nframes
                r = R{k};
                rval = min(r(r &gt;= 0)); <span class="comment">% Take the minimum value &gt;= 0.</span>
                <span class="keyword">if</span> isempty(rval)
                    theta0(k) = NaN;
                    kappa0(k) = NaN;
                <span class="keyword">else</span>
                    ind = find(r==rval,1,<span class="string">'first'</span>);
                    theta0(k) = THETA{k}(ind);
                    kappa0(k) = KAPPA{k}(ind);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [thetap,kappap,y,x,t] = get_theta_kappa_at_point(obj,tid,r_in_mm)
            <span class="comment">%</span>
            <span class="comment">%   [thetap,kappap,y,x,t] = get_theta_kappa_at_point(obj,tid,r_in_mm)</span>
            <span class="comment">%</span>
            <span class="comment">%   INPUTS:</span>
            <span class="comment">%       tid:  Trajectory ID (as an integer) or whisker name (as a string).</span>
            <span class="comment">%</span>
            <span class="comment">%       r_in_mm: Distance along whisker at which to measure theta and kappa.</span>
            <span class="comment">%                Note that this calculation does not extrapolate back</span>
            <span class="comment">%                to the follicle. Alternatively, this argument can be given</span>
            <span class="comment">%                as the string 'max', in which case theta, kappa, y, x are</span>
            <span class="comment">%                given for the furthest arc-length distance along the whisker.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   OUTPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%       thetap: Theta at radial distance specified by r_in_mm.</span>
            <span class="comment">%                     Radial distance is measured outward from the</span>
            <span class="comment">%                     intersection of the whisker and the mask, if present.</span>
            <span class="comment">%                     In degrees.</span>
            <span class="comment">%</span>
            <span class="comment">%       kappap: Kappa at radial distance specified by r_in_mm.</span>
            <span class="comment">%               Radial distance is determined outward from the intersection</span>
            <span class="comment">%               of the whisker and the mask, if present. Units of 1/pixels.</span>
            <span class="comment">%</span>
            <span class="comment">%       x,y: The image (pixel) coordinates of the point at r_in_mm.</span>
            <span class="comment">%</span>
            <span class="comment">%       t: The corresponding times of each observation.</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> isnumeric(tid) <span class="comment">% Trajectory ID specified.</span>
                ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">elseif</span> ischar(tid) <span class="comment">% Whisker name specified.</span>
                ind = strmatch(tid,obj.whiskerNames,<span class="string">'exact'</span>);
            <span class="keyword">else</span>
                error(<span class="string">'Invalid type for argument ''tid''.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
            f = t / obj.framePeriodInSec;
            nframes = length(f);

            [R,THETA,KAPPA,Y,X] = obj.arc_length_theta_and_kappa(tid);

            thetap = zeros(1,nframes);
            kappap = zeros(1,nframes);
            x = zeros(1,nframes);
            y = zeros(1,nframes);

            <span class="keyword">if</span> ischar(r_in_mm)
                <span class="keyword">if</span> ~strcmp(r_in_mm,<span class="string">'max'</span>)
                    error(<span class="string">'Invalid value for argument ''r_in_mm'''</span>)
                <span class="keyword">end</span>
                <span class="keyword">for</span> k=1:nframes
                    <span class="keyword">if</span> isempty(R{k})
                        thetap(k) = NaN;
                        kappap(k) = NaN;
                        y(k) = NaN;
                        x(k) = NaN;
                    <span class="keyword">else</span>
                        thetap(k) = THETA{k}(end);
                        kappap(k) = KAPPA{k}(end);
                        y(k) = Y{k}(end);
                        x(k) = X{k}(end);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="keyword">for</span> k=1:nframes
                    r = R{k} / obj.pxPerMm;
                    rval = min(r(r &gt;= r_in_mm)); <span class="comment">% Take the minimum value &gt;= r_in_mm.</span>
                    <span class="keyword">if</span> isempty(rval)
                        thetap(k) = NaN;
                        kappap(k) = NaN;
                        y(k) = NaN;
                        x(k) = NaN;
                    <span class="keyword">else</span>
                        ind = find(r==rval,1,<span class="string">'first'</span>);
                        thetap(k) = THETA{k}(ind);
                        kappap(k) = KAPPA{k}(ind);
                        y(k) = Y{k}(ind);
                        x(k) = X{k}(ind);
                    <span class="keyword">end</span>
                <span class="keyword">end</span>
            <span class="keyword">end</span>


        <span class="keyword">end</span>

        <span class="keyword">function</span> [thetap,kappap,y,x,t] = get_theta_kappa_at_roi_point(obj,tid,r_in_mm)
            <span class="comment">%</span>
            <span class="comment">%   [thetap,kappap,y,x,t] = get_theta_kappa_at_roi_point(obj,tid,r_in_mm)</span>
            <span class="comment">%</span>
            <span class="comment">%   INPUTS:</span>
            <span class="comment">%       tid:  Trajectory ID (as an integer) or whisker name (as a string).</span>
            <span class="comment">%</span>
            <span class="comment">%       r_in_mm: Distance along whisker at which to measure theta and kappa.</span>
            <span class="comment">%                Note that this calculation does not extrapolate back</span>
            <span class="comment">%                to the follicle. Also, r_in_mm **MUST FALL WITHIN THE ROI**</span>
            <span class="comment">%                or else a NaN is returned.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   OUTPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%       thetap: Theta at radial distance specified by r_in_mm.</span>
            <span class="comment">%                     Radial distance is measured outward from the</span>
            <span class="comment">%                     intersection of the whisker and the mask, if present.</span>
            <span class="comment">%                     In degrees.</span>
            <span class="comment">%</span>
            <span class="comment">%       kappap: Kappa at radial distance specified by r_in_mm.</span>
            <span class="comment">%               Radial distance is determined outward from the intersection</span>
            <span class="comment">%               of the whisker and the mask, if present. Units of 1/pixels.</span>
            <span class="comment">%</span>
            <span class="comment">%       x,y: The image (pixel) coordinates of the point at r_in_mm.</span>
            <span class="comment">%</span>
            <span class="comment">%       t: The corresponding times of each observation.</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> isnumeric(tid) <span class="comment">% Trajectory ID specified.</span>
                ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">elseif</span> ischar(tid) <span class="comment">% Whisker name specified.</span>
                ind = strmatch(tid,obj.whiskerNames,<span class="string">'exact'</span>);
            <span class="keyword">else</span>
                error(<span class="string">'Invalid type for argument ''tid''.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind};
            f = t / obj.framePeriodInSec;
            nframes = length(f);

            [R,THETA,KAPPA,Y,X] = obj.arc_length_theta_and_kappa_in_roi(tid);

            thetap = zeros(1,nframes);
            kappap = zeros(1,nframes);
            x = zeros(1,nframes);
            y = zeros(1,nframes);

            <span class="keyword">for</span> k=1:nframes
                r = R{k} / obj.pxPerMm;
                rval = min(r(r &gt;= r_in_mm)); <span class="comment">% Take the minimum value &gt;= r_in_mm.</span>
                <span class="keyword">if</span> isempty(rval)
                    disp(<span class="string">'r_in_mm not found within fitted whisker ROI; setting to NaN for this frame.'</span>)
                    thetap(k) = NaN;
                    kappap(k) = NaN;
                    y(k) = NaN;
                    x(k) = NaN;
                <span class="keyword">else</span>
                    ind = find(r==rval,1,<span class="string">'first'</span>);
                    thetap(k) = THETA{k}(ind);
                    kappap(k) = KAPPA{k}(ind);
                    y(k) = Y{k}(ind);
                    x(k) = X{k}(ind);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> [M0,Faxial,t,varargout] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,<span class="keyword">...</span>
                whisker_length,youngs_modulus,baseline_time_or_kappa_value, varargin)
            <span class="comment">%</span>
            <span class="comment">%   DHO 6/18/10 NOTE: This should be rewritten using inputParser.</span>
            <span class="comment">%</span>
            <span class="comment">% USAGE:</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,varargout] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,deltaKappa] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,deltaKappa,Fnorm] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact,distanceToPoleCenter] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact,distanceToPoleCenter, meanKappa] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact,distanceToPoleCenter, meanKappa, Flateral] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value)</span>
            <span class="comment">%</span>
            <span class="comment">%    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact,distanceToPoleCenter, meanKappa, Flateral] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...</span>
            <span class="comment">%      whisker_length,youngs_modulus,baseline_time_or_kappa_value,proximity_threshold)</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">% 	tid:  trajectory ID or string specifying the whisker the use.</span>
            <span class="comment">% 	r_point: radial distance along whisker at which to measure kappa. In mm.</span>
            <span class="comment">% 	whisker_radius_at_base: Given in microns.</span>
            <span class="comment">% 	whisker_length: Given in mm.</span>
            <span class="comment">% 	youngs_modulus: In Pa.</span>
            <span class="comment">% 	baseline_time_or_kappa_value: Either (1) a 1x2 vector giving starting and stopping times (inclusive) for measuring baseline whisker curvature, in sec;</span>
            <span class="comment">%                                 or (2) a scaler giving a baseline kappa value (measured by the user separately) to directly subtract from kappa</span>
            <span class="comment">%                                 timeseries, in 1/mm.</span>
            <span class="comment">%</span>
            <span class="comment">%   Optionally,</span>
            <span class="comment">%</span>
            <span class="comment">%   proximity_threshold:  Optional argument giving distance from nearest point on whisker</span>
            <span class="comment">%                         to bar center, in units of bar radius, beyond which</span>
            <span class="comment">%                         the whisker will be extrapolated along the last theta in</span>
            <span class="comment">%                         order to determine distance between whisker and bar.</span>
            <span class="comment">%</span>
            <span class="comment">% OUTPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">% 	M0:  Moment at the follicle. In Newton-meters.</span>
            <span class="comment">% 	Faxial: Axial force into follice. In Newtons.</span>
            <span class="comment">% 	t: The time of each M0, Faxial observation. In sec.</span>
            <span class="comment">%</span>
            <span class="comment">% 	Optionally,</span>
            <span class="comment">%</span>
            <span class="comment">% 	deltaKappa = Change from baseline curvature, at point specified by r_point. In 1/mm.</span>
            <span class="comment">% 	Fnorm - The force on the whisker normal to the contacted object. In Newtons.</span>
            <span class="comment">%   thetaAtBase - The whisker angle nearest the follicle. In degrees.</span>
            <span class="comment">%   thetaAtContact - The whisker angle nearest the point of contact. I.e., nearest the center of the pole. In degrees.</span>
            <span class="comment">%   distanceToPoleCenter - The closest distance between the whisker and the center of the pole. In mm.</span>
            <span class="comment">%   meanKappa - The mean of kappa over the entire secondary polynomial fitted ROI. In 1/mm.</span>
            <span class="comment">%   Flateral - Lateral force, orthogonal to Faxial; pushes the whisker against the posterior side of the follicle. In Newtons.</span>
            <span class="comment">%</span>
            <span class="comment">% REQUIRES:</span>
            <span class="comment">% 	-Follicle coordinates are already computed.</span>
            <span class="comment">% 	-Property pxPerMm is set correctly for the current videographic conditions.</span>
            <span class="comment">% 	-Property faceSideInImage is set correctly.</span>
            <span class="comment">% 	-Property barPos is set correctly.</span>
            <span class="comment">%</span>
            <span class="comment">% Assumptions:</span>
            <span class="comment">% 	-Whisker is conical.</span>
            <span class="comment">%   -Young's modulus is same everywhere on whisker.</span>
            <span class="comment">%   -Whisker cross-section is circular.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> nargin &gt; 7
                proximity_threshold = varargin{1};
            <span class="keyword">else</span>
                proximity_threshold = -1; <span class="comment">% -1 means unused</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> isnumeric(tid) <span class="comment">% Trajectory ID specified.</span>
                ind = find(obj.trajectoryIDs == tid);
            <span class="keyword">elseif</span> ischar(tid) <span class="comment">% Whisker name specified.</span>
                ind = strmatch(tid,obj.whiskerNames,<span class="string">'exact'</span>);
            <span class="keyword">else</span>
                error(<span class="string">'Invalid type for argument ''tid''.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(ind)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.follicleCoordsX) || isempty(obj.follicleCoordsX)
                error([<span class="string">'obj.follicleCoordsX or obj.follicleCoordsY is empty. '</span> <span class="keyword">...</span>
                    <span class="string">'Must run obj.recompute_cached_follicle_coords before this method.'</span>])
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.barPos)
                error(<span class="string">'obj.barPos is empty. Bar position is required to define point of contact.'</span>)
            <span class="keyword">end</span>

            r_point = r_point * 1e-3; <span class="comment">% Argument given in mm; convert to meters.</span>
            whisker_radius_at_base = whisker_radius_at_base * 1e-6; <span class="comment">% Argument given in micrometers; convert to meters.</span>
            whisker_length = whisker_length * 1e-3;  <span class="comment">% Argument given in mm; convert to meters.</span>

            pixelsPerMeter = 1e3 * obj.pxPerMm;

            <span class="comment">% DHO 11/5/10: Need to access follicleExtrapDistanceInPix and then add that (mm/pixel converted) value</span>
            <span class="comment">% to r_point in equation for II. Otherwise the base of the cone (whisker) starts not at the follicle but</span>
            <span class="comment">% at the first tracked point or at the intersection of the whisker and the mask, if a mask is defined.</span>
            II = pi/4*(whisker_radius_at_base*(1-(r_point+obj.follicleExtrapDistInPix./pixelsPerMeter)/whisker_length))^4; <span class="comment">% In Meters^4. Eqn A2,3 from Birdwell et al.</span>

<span class="comment">%             II = pi/4*(whisker_radius_at_base*(1-r_point/whisker_length))^4; % In Meters^4. Eqn A2,3 from Birdwell et al.</span>
            EI = youngs_modulus*II; <span class="comment">% Meter^4-pascals. Bending stiffness at point r_point.</span>

            x0 = obj.follicleCoordsX{ind};
            y0 = obj.follicleCoordsY{ind};

            <span class="keyword">if</span> isempty(x0) || isempty(y0)
              disp([<span class="string">'No follicle coordinates computed for tid '</span> int2str(tid) <span class="string">', cannot compute forces, setting to NaN.'</span>])
              t = obj.time{ind};
              x0 = nan(size(t));
              y0 = nan(size(t));
            <span class="keyword">end</span>


            <span class="comment">% Could speed up by combining next few lines, since several call arc_length_theta_and_kappa().</span>
            <span class="comment">% From one function call, need to get:</span>
            <span class="comment">%   t, theta0, kappaPoint, yPoint, xPoint, meanKappa (from ROIKAPPA), thetaContact, yContact, xContact, distanceToPoleCenter</span>

            FC = obj.get_force_calc_vals(tid, r_point*1e3, proximity_threshold); <span class="comment">% Give r_point argument in mm.</span>

            <span class="comment">% get_force_calc_vals() combines:</span>
            <span class="comment">%            [theta0,tmp,t] = obj.get_theta_kappa_at_base(tid);</span>
            <span class="comment">%            [tmp,kappaPoint,yPoint,xPoint,t] = obj.get_theta_kappa_at_roi_point(tid,r_point*1e3)</span>
            <span class="comment">%            [tmp1,thetaContact,tmp2,yContact,xContact,distanceToPoleCenter,t] = obj.get_r_theta_kappa_nearest_bar(tid);</span>
            <span class="comment">%</span>
            <span class="comment">% FC is structure with fields: t (sec), theta0 (degrees), kappaPoint (1/pixels), yPoint (pixels), xPoint (pixels),</span>
            <span class="comment">% meanKappa (in ROI; 1/pixels), thetaContact (degrees), yContact (pixels), xContact (pixels), distanceToPoleCenter (pixels).</span>
                        <span class="comment">% Construct output structure:</span>

            t = FC.t; <span class="comment">% In sec</span>
            theta0 = FC.theta0; <span class="comment">% In degrees</span>
            kappaPoint = FC.kappaPoint; <span class="comment">% In 1/pixels</span>
            yPoint = FC.yPoint; <span class="comment">% In pixels</span>
            xPoint = FC.xPoint; <span class="comment">% In pixels</span>
            meanKappa = FC.meanKappa; <span class="comment">% In 1/pixels.</span>
            thetaContact = FC.thetaContact; <span class="comment">% In 1/pixels</span>
            yContact = FC.yContact; <span class="comment">% In pixels</span>
            xContact = FC.xContact; <span class="comment">% In pixels</span>
            distanceToPoleCenter = FC.distanceToPoleCenter; <span class="comment">% In pixels</span>

<span class="comment">%            [theta0, t] = obj.get_fitted_line_angle_in_roi(obj,tid,[0 32])</span>
            [theta0,tmp,t] = obj.get_theta_kappa_at_point(tid,0.5); <span class="comment">%</span>

<span class="comment">%             [tmp,kappaPoint,yPoint,xPoint,t] = obj.get_theta_kappa_at_roi_point(tid,r_point*1e3); % Give second argument in mm. kappaPoint in 1/pixels.</span>

            <span class="keyword">if</span> numel(baseline_time_or_kappa_value)==2
                disp([<span class="string">'Using kappa averaged over times '</span> num2str(baseline_time_or_kappa_value(1)) <span class="string">' to '</span> num2str(baseline_time_or_kappa_value(2)) <span class="keyword">...</span>
                    <span class="string">' (inclusive) for baseline kappa for trajectory ID '</span> int2str(tid) <span class="string">'.'</span>])
                baselineKappa = pixelsPerMeter * nanmean(kappaPoint(t &gt;= baseline_time_or_kappa_value(1) &amp; t &lt;= baseline_time_or_kappa_value(2))); <span class="comment">% Now in 1/m.</span>
            <span class="keyword">elseif</span> numel(baseline_time_or_kappa_value)==1
                disp([<span class="string">'Using user-specified kappa value of '</span> num2str(baseline_time_or_kappa_value) <span class="string">' 1/mm for baseline kappa for trajectory ID '</span> int2str(tid) <span class="string">'.'</span>])
                baselineKappa = baseline_time_or_kappa_value * 1e3; <span class="comment">% baseline_time_or_kappa_value given in 1/mm; convert to 1/m.</span>
            <span class="keyword">else</span>
                error(<span class="string">'Argument ''baseline_time_or_kappa_value'' has wrong number of elements.'</span>)
            <span class="keyword">end</span>

            kappaPoint = pixelsPerMeter * kappaPoint - baselineKappa; <span class="comment">% In 1/m.</span>

<span class="comment">%             [tmp,tmp1,ROIKAPPA] = obj.arc_length_theta_and_kappa_in_roi(tid);</span>
<span class="comment">%             meanKappa = cellfun(@mean, ROIKAPPA); % In 1/pixels.</span>

            meanKappa = pixelsPerMeter * meanKappa - baselineKappa;

<span class="comment">%             [tmp1,thetaContact,tmp2,yContact,xContact,distanceToPoleCenter,t] = obj.get_r_theta_kappa_nearest_bar(tid);</span>

            theta0 = theta0*(2*pi/360); <span class="comment">% Convert all angles to radians.</span>
            thetaContact = thetaContact*(2*pi/360);

            rPointNorm = sqrt((xContact-xPoint).^2 + (yContact-yPoint).^2) / pixelsPerMeter; <span class="comment">% in meters.</span>
            r0Norm = sqrt((xContact-x0).^2 + (yContact-y0).^2) / pixelsPerMeter; <span class="comment">% in meters.</span>

            <span class="comment">%**** CHECK: NEED TO ACCOUNT FROM PROTRACTION DIRECTION IN FOLLOWING? *******</span>

            <span class="comment">% Get angle of vector from r_point to contact point:</span>
            dx = (xContact-xPoint); dy = (yContact-yPoint);
            <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) || strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>)
                thetaPoint2Cont = atan(dx./dy);
            <span class="keyword">else</span>
                thetaPoint2Cont = atan(dy./dx);
            <span class="keyword">end</span>

            <span class="comment">% Get angle of vector from follicle to contact point:</span>
            dx = (xContact-x0); dy = (yContact-y0);
            <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>) || strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>)
                thetaFoll2Cont = atan(dx./dy);
            <span class="keyword">else</span>
                thetaFoll2Cont = atan(dy./dx);
            <span class="keyword">end</span>

            Fnorm = (kappaPoint*EI) ./ (rPointNorm .* sin(pi/2 + thetaPoint2Cont - thetaContact)); <span class="comment">% in Newtons</span>
            Faxial = Fnorm.*sin(theta0 - thetaContact); <span class="comment">% in Newtons.</span>
            Flateral = Fnorm.*cos(theta0 - thetaContact); <span class="comment">% in Newtons.</span>
            M0 = r0Norm.*Fnorm.*sin(pi/2 + thetaFoll2Cont - thetaContact); <span class="comment">% in Newton-meters</span>

            <span class="keyword">if</span> nargout &gt; 3
                varargout{1} = kappaPoint / 1e3; <span class="comment">% kappaPoint in 1/m; return in 1/mm.</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargout &gt; 4
                varargout{2} = Fnorm;
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargout &gt; 5
                varargout{3} = theta0 / (2*pi/360); <span class="comment">% Whisker angle nearest the follicle. Currently in radians; return in degrees.</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargout &gt; 6
                varargout{4} = thetaContact / (2*pi/360); <span class="comment">% Whisker angle at point nearest center of pole. Currently in radians; return in degrees.</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargout &gt; 7
                varargout{5} = distanceToPoleCenter / obj.pxPerMm; <span class="comment">% distanceToPoleCenter in pixels; return in mm.</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargout &gt; 8
               varargout{6} = meanKappa / 1e3; <span class="comment">% meanKappa in 1/m; return in 1/mm.</span>
            <span class="keyword">end</span>
            <span class="keyword">if</span> nargout &gt; 9
               varargout{7} = Flateral; <span class="comment">% In Newtons.</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> FC = get_force_calc_vals(obj, tid, r_in_mm, varargin)
            <span class="comment">%</span>
            <span class="comment">% INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">% 	tid:  trajectory ID or string specifying the whisker the use.</span>
            <span class="comment">% 	r_in_mm: radial distance along whisker at which to measure kappa. In mm.</span>
            <span class="comment">%</span>
            <span class="comment">%   Optionally, varargin{1} can be 'proximity_threshold' argument, giving distance from nearest point on whisker</span>
            <span class="comment">%    to bar center, in units of bar radius, beyond which</span>
            <span class="comment">%    the whisker will be extrapolated along the last theta in</span>
            <span class="comment">%    order to determine distance between whisker and bar.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">% OUTPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">% FC: A structure with fields: t (sec), theta0 (degrees), kappaPoint (1/pixels), yPoint (pixels), xPoint (pixels),</span>
            <span class="comment">% meanKappa (in ROI; 1/pixels), thetaContact (degrees), yContact (pixels), xContact (pixels), distanceToPoleCenter (pixels).</span>
            <span class="comment">%</span>
            <span class="comment">% Explanation of fields:</span>
            <span class="comment">%       theta0: Theta at radial distance 0. Radial distance 0 is determined</span>
            <span class="comment">%                     in part by the mask, if present. In degrees.</span>
            <span class="comment">%</span>
            <span class="comment">% This method combines features of the following methods, but is more efficient</span>
            <span class="comment">% than calling all of the following methods separately:</span>
            <span class="comment">%            [theta0,tmp,t] = obj.get_theta_kappa_at_base(tid);</span>
            <span class="comment">%            [tmp,kappaPoint,yPoint,xPoint,t] = obj.get_theta_kappa_at_roi_point(tid,r_point*1e3)</span>
            <span class="comment">%            [tmp1,thetaContact,tmp2,yContact,xContact,distanceToPoleCenter,t] = obj.get_r_theta_kappa_nearest_bar(tid);</span>
            <span class="comment">%</span>
            <span class="comment">%</span>


            <span class="comment">%----------------------------------</span>

            <span class="comment">%   [theta0,kappa0,t] = get_theta_kappa_at_base(obj,tid)</span>
            <span class="comment">%</span>
            <span class="comment">%   INPUTS:</span>
            <span class="comment">%       tid:  Trajectory ID (as an integer) or whisker name (as a string).</span>
            <span class="comment">%</span>
            <span class="comment">%   OUTPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%       theta0: Theta at radial distance 0. Radial distance 0 is determined</span>
            <span class="comment">%                     in part by the mask, if present. In degrees.</span>
            <span class="comment">%</span>
            <span class="comment">%       t: The corresponding times of each observation.</span>
            <span class="comment">%</span>

            <span class="keyword">if</span> isnumeric(tid) <span class="comment">% Trajectory ID specified.</span>
                ind_tid = find(obj.trajectoryIDs == tid);
            <span class="keyword">elseif</span> ischar(tid) <span class="comment">% Whisker name specified.</span>
                ind_tid = strmatch(tid,obj.whiskerNames,<span class="string">'exact'</span>);
            <span class="keyword">else</span>
                error(<span class="string">'Invalid type for argument ''tid''.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(ind_tid)
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>
            t = obj.time{ind_tid};

            <span class="keyword">if</span> all(isnan(t)) <span class="comment">%*** MODIFY?</span>
                disp([<span class="string">'Nothing tracked for tid '</span> int2str(tid) <span class="string">'; setting theta0,kappa0,t to NaN.'</span>])
                theta0 = NaN;
                t = NaN;
                <span class="keyword">return</span>
            <span class="keyword">end</span>

            f = t / obj.framePeriodInSec;
            nframes = length(f);

            [R,THETA] = obj.arc_length_and_theta(tid);

            theta0 = zeros(1,nframes);

            <span class="keyword">for</span> k=1:nframes
                r = R{k};
                rval = min(r(r &gt;= 0)); <span class="comment">% Take the minimum value &gt;= 0.</span>
                <span class="keyword">if</span> isempty(rval)
                    theta0(k) = NaN;
                <span class="keyword">else</span>
                    ind = find(r==rval,1,<span class="string">'first'</span>);
                    theta0(k) = THETA{k}(ind);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">%----------------------------------</span>
            <span class="comment">%   [thetap,kappap,y,x,t] = get_theta_kappa_at_roi_point(obj,tid,r_in_mm)</span>
            <span class="comment">%</span>
            <span class="comment">%   INPUTS:</span>
            <span class="comment">%       tid:  Trajectory ID (as an integer) or whisker name (as a string).</span>
            <span class="comment">%</span>
            <span class="comment">%       r_in_mm: Distance along whisker at which to measure theta and kappa.</span>
            <span class="comment">%                Note that this calculation does not extrapolate back</span>
            <span class="comment">%                to the follicle. Also, r_in_mm **MUST FALL WITHIN THE ROI**</span>
            <span class="comment">%                or else a NaN is returned.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   OUTPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%       kappaPoint: Kappa at radial distance specified by r_in_mm.</span>
            <span class="comment">%               Radial distance is determined outward from the intersection</span>
            <span class="comment">%               of the whisker and the mask, if present. Units of 1/pixels.</span>
            <span class="comment">%</span>
            <span class="comment">%       xPoint,yPoint: The image (pixel) coordinates of the point at r_in_mm.</span>
            <span class="comment">%</span>
            <span class="comment">%       t: The corresponding times of each observation.</span>
            <span class="comment">%</span>

            [R_ROI,THETA_ROI,KAPPA_ROI,Y,X] = obj.arc_length_theta_and_kappa_in_roi(tid);

            kappaPoint = zeros(1,nframes);
            xPoint = zeros(1,nframes);
            yPoint = zeros(1,nframes);

            <span class="keyword">for</span> k=1:nframes
                r = R_ROI{k} / obj.pxPerMm;
                rval = min(r(r &gt;= r_in_mm)); <span class="comment">% Take the minimum value &gt;= r_in_mm.</span>
                <span class="keyword">if</span> isempty(rval)
                    disp(<span class="string">'r_in_mm not found within fitted whisker ROI; setting to NaN for this frame.'</span>)
                    kappaPoint(k) = NaN;
                    yPoint(k) = NaN;
                    xPoint(k) = NaN;
                <span class="keyword">else</span>
                    ind = find(r==rval,1,<span class="string">'first'</span>);
                    kappaPoint(k) = KAPPA_ROI{k}(ind);
                    yPoint(k) = Y{k}(ind);
                    xPoint(k) = X{k}(ind);
                <span class="keyword">end</span>
            <span class="keyword">end</span>
            <span class="comment">%----------------------------------</span>
            <span class="comment">%   [rNearest,thetaNearest,kappaNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid)</span>
            <span class="comment">%   [rNearest,thetaNearest,kappaNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid,proximity_threshold)</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%   INPUTS:</span>
            <span class="comment">%       tid:  Trajectory ID (as an integer) or whisker name (as a string).</span>
            <span class="comment">%       proximity_threshold:  Optional argument giving distance from nearest point on whisker</span>
            <span class="comment">%               to bar center, in units of bar radius, beyond which</span>
            <span class="comment">%               the whisker will be extrapolated along the last theta in</span>
            <span class="comment">%               order to determine distance between whisker and bar.</span>
            <span class="comment">%</span>
            <span class="comment">%   OUTPUTS:</span>
            <span class="comment">%       rNearest: Arc-length (radial) distance along whisker to point nearest</span>
            <span class="comment">%                 center of the bar. Units of pixels.</span>
            <span class="comment">%       thetaNearest: Theta at rNearest.</span>
            <span class="comment">%       kappaNearest: Kappa at rNearest.</span>
            <span class="comment">%       YNearest: Image-coordinate Y value at rNearest. This estimates point of contact. In pixels.</span>
            <span class="comment">%       XNearest: Image-coordinate X value at rNearest. This estimates point of contact. In pixels.</span>
            <span class="comment">%       dist: Distance from bar center to nearest point on whisker. Units of pixels.</span>
            <span class="comment">%       t: The corresponding times of each observation.</span>
            <span class="comment">%</span>

            <span class="keyword">if</span> nargin &lt; 4
                proximity_threshold = -1;
            <span class="keyword">else</span>
                proximity_threshold = varargin{1};
            <span class="keyword">end</span>

            <span class="comment">% Add any offset to the tracked bar position:</span>
            <span class="keyword">if</span> isempty(obj.barPosOffset);
                bp = obj.barPosClean;
            <span class="keyword">else</span>
                bp = obj.barPosClean;
                <span class="keyword">if</span> size(obj.barPosOffset,1)==1
                    bp = bp + repmat([0 obj.barPosOffset],size(bp,1),1);
                <span class="keyword">elseif</span> size(obj.barPosOffset,1)==size(bp,1) &amp;&amp; size(obj.barPosOffset,2)==2
                    bp = bp + obj.barPosOffset;
                <span class="keyword">else</span>
                    error(<span class="string">'Size of obj.barPosOffset is not valid; must be either 1 x 2 or nframes x 2.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            bar_f = bp(:,1);
            bar_x = bp(:,2);
            bar_y = bp(:,3);

            <span class="comment">%             [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);</span>

            thetaNearest = zeros(1,nframes);
            dist = zeros(1,nframes);
            xNearest = zeros(1,nframes);
            yNearest = zeros(1,nframes);

            q = linspace(0,1); <span class="comment">% This must be same as that used in obj.arc_length_theta_and_kappa().</span>

            fittedX = obj.polyFits{ind_tid}{1};
            fittedY = obj.polyFits{ind_tid}{2};

            <span class="keyword">for</span> k=1:nframes
                <span class="comment">%                 disp(['Computing nearest-point values for frame=' int2str(k)])</span>
                px = fittedX(k,:);
                py = fittedY(k,:);

                x = polyval(px,q);
                y = polyval(py,q);

                <span class="comment">%                 ind = bar_f == f(k);</span>
                ind = abs(bar_f-f(k)) &lt; 1e-12;

                <span class="keyword">if</span> ~any(ind) || any(isnan(x)) || any(isnan(y))
                    thetaNearest(k) = NaN;
                    xNearest(k) = NaN;
                    yNearest(k) = NaN;
                    dist(k) = NaN;
                    <span class="keyword">continue</span>
                <span class="keyword">end</span>
                bx = bar_x(ind); <span class="comment">% center of bar -- offset if appropriate</span>
                by = bar_y(ind);

                <span class="comment">% Find closest point iteratively:</span>
                npoints = length(x);
                d = zeros(npoints,1);
                <span class="keyword">for</span> j=1:npoints
                    d(j) = sqrt((x(j)-bx)^2 + (y(j)-by)^2);
                <span class="keyword">end</span>
                ind = find(d==min(d));
                ind = ind(1); <span class="comment">% in case there are points of equal distance, take first; Later this should be first along arc-length of whisker*****</span>

                <span class="keyword">if</span> proximity_threshold &lt; 0
                    dist(k) = d(ind) - obj.barRadius;
                <span class="keyword">elseif</span> d(ind) &lt; obj.barRadius*proximity_threshold
                    thetaW = THETA{k}(ind); <span class="comment">% Angle of whisker at last point on whisker.</span>

                    <span class="keyword">if</span> strcmp(obj.faceSideInImage,<span class="string">'top'</span>)
                        a = [tand(thetaW) 1]; <span class="comment">% Vector extending from last point on whisker along angle of whisker.</span>
                    <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'bottom'</span>)  <span class="comment">% DHO, 12oct11: Don't have test data for these conditions, remains untested</span>
                        a = [tand(thetaW) -1]; <span class="comment">% Vector extending from last point on whisker along angle of whisker.</span>
                    <span class="keyword">elseif</span> strcmp(obj.faceSideInImage,<span class="string">'left'</span>)
                        a = [1 tand(thetaW)]; <span class="comment">% Vector extending from last point on whisker along angle of whisker.</span>
                    <span class="keyword">else</span> strcmp(obj.faceSideInImage,<span class="string">'right'</span>) <span class="comment">% DHO, 12oct11: Don't have test data for these conditions, remains untested</span>
                        a = [-1 tand(thetaW)]; <span class="comment">% Vector extending from last point on whisker along angle of whisker.</span>
                    <span class="keyword">end</span>

                    b = [bx-x(ind) by-y(ind)]; <span class="comment">% Vector from last point on whisker to pole center.</span>
                    a_norm = norm(a);
                    b_norm = norm(b);
                    thetaWP = abs(acosd(dot(a,b)/(a_norm*b_norm))); <span class="comment">% Angle between whisker and pole. Don't care about sign, so take absolute value.</span>

                    dist(k) = b_norm*sind(thetaWP);
                    dist(k) = dist(k) - obj.barRadius;
                <span class="keyword">else</span>
                    dist(k) = d(ind) - obj.barRadius;
                <span class="keyword">end</span>

                thetaNearest(k) = THETA{k}(ind);
                xNearest(k) = x(ind);
                yNearest(k) = y(ind);
            <span class="keyword">end</span>

            <span class="comment">% Construct output structure:</span>
            FC.t = t; <span class="comment">% In sec</span>
            FC.theta0 = theta0; <span class="comment">% In degrees</span>
            FC.kappaPoint = kappaPoint; <span class="comment">% In 1/pixels</span>
            FC.yPoint = yPoint; <span class="comment">% In pixels</span>
            FC.xPoint = xPoint; <span class="comment">% In pixels</span>
            FC.meanKappa = cellfun(@mean, KAPPA_ROI); <span class="comment">% In 1/pixels.</span>
            FC.thetaContact = thetaNearest; <span class="comment">% In 1/pixels</span>
            FC.yContact = yNearest; <span class="comment">% In pixels</span>
            FC.xContact = xNearest; <span class="comment">% In pixels</span>
            FC.distanceToPoleCenter = dist; <span class="comment">% In pixels</span>

        <span class="keyword">end</span>


        <span class="keyword">function</span> varargout = plot_fitted_whisker_time_projection(obj, tid, varargin)
            <span class="comment">%</span>
            <span class="comment">%   varargout = plot_fitted_whisker_time_projection(obj, tid, varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% USAGE:</span>
            <span class="comment">%       plot_fitted_whisker_time_projection(obj, tid, varargin)</span>
            <span class="comment">%       [X,Y] = plot_fitted_whisker_time_projection(obj, tid, varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% INPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">% tid: trajectory ID.  Only a single ID is allowed.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Plot color/symbol string.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{2}: Optional 2 x 1 vector giving starting and ending times (in seconds) to include in</span>
            <span class="comment">%               returned image, inclusive, starting with 0.</span>
            <span class="comment">%               Of format: [startTimeInSec endTimeInSec]. Can be empty ([]) to allow</span>
            <span class="comment">%               access to varargin{3}.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{3}: Cell array with two elements. First element is a 1x2 vector giving radial distance</span>
            <span class="comment">%              beginning and end points (inclusive) to draw in the color given in</span>
            <span class="comment">%              varargin{1}, in format [startRadialDistance stopRadialDistance]. Radial distance</span>
            <span class="comment">%              is whisker arc length moving outward from follicle and is in units of pixels.</span>
            <span class="comment">%              The second element of the cell array is the plot color/symbol string to use when</span>
            <span class="comment">%              plotting the radial segment of the whisker between startRadialDistance and</span>
            <span class="comment">%              stopRadialDistance.</span>
            <span class="comment">%</span>
            <span class="comment">% OUTPUTS:</span>
            <span class="comment">%</span>
            <span class="comment">% If no output argument is requested, only plotting happens.  If two output argument</span>
            <span class="comment">% is requested, two cell arrays of length nframes are returned, X, and Y, each element of which</span>
            <span class="comment">% contain the x and y data, respectively, that were plotted for a given frame.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> numel(tid) &gt; 1
                error(<span class="string">'Only a single trajectory ID is alowed.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 2
                plotString = varargin{1};
            <span class="keyword">else</span>
                plotString = <span class="string">'k-'</span>;
            <span class="keyword">end</span>

            t = obj.get_time(tid);

            <span class="keyword">if</span> nargin &gt; 3
                restrictTime = varargin{2};
                <span class="keyword">if</span> isempty(restrictTime)
                    restrictTime = [min(t) max(t)];
                <span class="keyword">elseif</span> restrictTime(2) &lt;= restrictTime(1)
                    error(<span class="string">'Invalid format for varargin{2}.'</span>)
                <span class="keyword">elseif</span> max(restrictTime) &gt; max(t)
                    disp(<span class="string">'Warning: varargin{2} exceeds max time; setting to max.'</span>)
                    restrictTime(restrictTime==max(restrictTime)) = max(t);
                    <span class="keyword">if</span> restrictTime(1)==restrictTime(2)
                        error(<span class="string">'varargin{2}: Both times exceed max time.'</span>)
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> min(restrictTime &lt; 0)
                    disp(<span class="string">'varargin{2}: times start at 0.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                restrictTime = [min(t) max(t)];
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 4
                <span class="keyword">if</span> ~iscell(varargin{3})
                    error(<span class="string">'Wrong format for varargin{3}.'</span>)
                <span class="keyword">end</span>
                plotString2 = varargin{3}{2};
                rstart = varargin{3}{1}(1);
                rstop = varargin{3}{1}(2);
            <span class="keyword">end</span>

            frameInds = find(t &gt;= restrictTime(1) &amp; t &lt;= restrictTime(2));

            hold <span class="string">on</span>; axis <span class="string">ij</span>

            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.polyFits)
                error(<span class="string">'obj.polyFits is empty.'</span>)
            <span class="keyword">end</span>

            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};

            nframes = length(frameInds);
            x = cell(1,nframes);
            y = cell(1,nframes);

            q = linspace(0,1);

            <span class="keyword">for</span> k=1:nframes
                f = frameInds(k);

                px = fittedX(f,:);
                py = fittedY(f,:);
                x{k} = polyval(px,q);
                y{k} = polyval(py,q);
            <span class="keyword">end</span>

            X = cell(1,nframes);
            Y = cell(1,nframes);

            <span class="keyword">if</span> nargin &gt; 4
                [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
                <span class="keyword">for</span> k=1:nframes
                    xx = x{k};
                    yy = y{k};
                    f = frameInds(k);
                    radDist = R{f};
                    plot(xx,yy,plotString)
                    rind = radDist &gt;= rstart &amp; radDist &lt;= rstop;
                    plot(xx(rind),yy(rind),plotString2)
                    X{k} = xx(rind);
                    Y{k} = yy(rind);
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="keyword">for</span> k=1:nframes
                    plot(x{k},y{k},plotString)
                    X{k} = x{k};
                    Y{k} = y{k};
                <span class="keyword">end</span>
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargout == 1 || nargout &gt; 2
                error(<span class="string">'Invalid number of output arguments.'</span>)
            <span class="keyword">elseif</span> nargout == 2
                varargout{1} = X;
                varargout{2} = Y;
            <span class="keyword">end</span>

        <span class="keyword">end</span>

        <span class="keyword">function</span> plot_fitted_whisker_ROI_time_projection(obj, tid, varargin)
            <span class="comment">%</span>
            <span class="comment">%   plot_fitted_whisker_time_ROI_projection(obj, tid, varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% Plots whisker, but only the part within the secondary polynomial</span>
            <span class="comment">% fitting ROI.</span>
            <span class="comment">%</span>
            <span class="comment">% tid: trajectory ID.  Only a single ID is allowed.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Plot color/symbol string.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{2}: Optional 2 x 1 vector giving starting and ending times (in seconds) to include in</span>
            <span class="comment">%               returned image, inclusive, starting with 0.</span>
            <span class="comment">%               Of format: [startTimeInSec endTimeInSec]. Can be empty ([]) to allow</span>
            <span class="comment">%               access to varargin{3}.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> numel(tid) &gt; 1
                error(<span class="string">'Only a single trajectory ID is alowed.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 2
                plotString = varargin{1};
            <span class="keyword">else</span>
                plotString = <span class="string">'k-'</span>;
            <span class="keyword">end</span>

            t = obj.get_time(tid);

            <span class="keyword">if</span> nargin &gt; 3
                restrictTime = varargin{2};
                <span class="keyword">if</span> isempty(restrictTime)
                    restrictTime = [min(t) max(t)];
                <span class="keyword">elseif</span> restrictTime(2) &lt;= restrictTime(1)
                    error(<span class="string">'Invalid format for varargin{2}.'</span>)
                <span class="keyword">elseif</span> max(restrictTime) &gt; max(t)
                    disp(<span class="string">'Warning: varargin{2} exceeds max time; setting to max.'</span>)
                    restrictTime(restrictTime==max(restrictTime)) = max(t);
                    <span class="keyword">if</span> restrictTime(1)==restrictTime(2)
                        error(<span class="string">'varargin{2}: Both times exceed max time.'</span>)
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> min(restrictTime &lt; 0)
                    disp(<span class="string">'varargin{2}: times start at 0.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                restrictTime = [min(t) max(t)];
            <span class="keyword">end</span>

            frameInds = find(t &gt;= restrictTime(1) &amp; t &lt;= restrictTime(2));

            hold <span class="string">on</span>; axis <span class="string">ij</span>

            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.polyFitsROI)
                error(<span class="string">'obj.polyFitsROI is empty.'</span>)
            <span class="keyword">end</span>

            fittedX = obj.polyFitsROI{ind}{1};
            fittedY = obj.polyFitsROI{ind}{2};
            fittedQ = obj.polyFitsROI{ind}{3};

            nframes = length(frameInds);
            x = cell(1,nframes);
            y = cell(1,nframes);

            <span class="keyword">for</span> k=1:nframes
                f = frameInds(k);

                px = fittedX(f,:);
                py = fittedY(f,:);
                pq = fittedQ(f,:);

                q = linspace(pq(1),pq(2));

                x{k} = polyval(px,q);
                y{k} = polyval(py,q);

                plot(x{k},y{k},plotString)
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plot_fitted_whisker_movie(obj, tid, varargin)
            <span class="comment">%</span>
            <span class="comment">%   plot_fitted_whisker_movie(obj, tid, varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% tid: trajectory ID.  Only a single ID is allowed.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Plot color/symbol string.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{2}: Optional 2 x 1 vector giving starting and ending times (in seconds) to include in</span>
            <span class="comment">%               returned image, inclusive, starting with 0.</span>
            <span class="comment">%               Of format: [startTimeInSec endTimeInSec]. Can be empty ([]) to allow</span>
            <span class="comment">%               access to varargin{3}.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{3}: Cell array with two elements. First element is a 1x2 vector giving radial distance</span>
            <span class="comment">%              beginning and end points (inclusive) to draw in the color given in</span>
            <span class="comment">%              varargin{1}, in format [startRadialDistance stopRadialDistance]. Radial distance</span>
            <span class="comment">%              is whisker arc length moving outward from follicle and is in units of pixels.</span>
            <span class="comment">%              The second element of the cell array is the plot color/symbol string to use when</span>
            <span class="comment">%              plotting the radial segment of the whisker between startRadialDistance and</span>
            <span class="comment">%              stopRadialDistance.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> numel(tid) &gt; 1
                error(<span class="string">'Only a single trajectory ID is alowed.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 2
                plotString = varargin{1};
            <span class="keyword">else</span>
                plotString = <span class="string">'k-'</span>;
            <span class="keyword">end</span>

            t = obj.get_time(tid);

            <span class="keyword">if</span> nargin &gt; 3
                restrictTime = varargin{2};
                <span class="keyword">if</span> isempty(restrictTime)
                    restrictTime = [min(t) max(t)];
                <span class="keyword">elseif</span> restrictTime(2) &lt;= restrictTime(1)
                    error(<span class="string">'Invalid format for varargin{2}.'</span>)
                <span class="keyword">elseif</span> max(restrictTime) &gt; max(t)
                    disp(<span class="string">'Warning: varargin{2} exceeds max time; setting to max.'</span>)
                    restrictTime(restrictTime==max(restrictTime)) = max(t);
                    <span class="keyword">if</span> restrictTime(1)==restrictTime(2)
                        error(<span class="string">'varargin{2}: Both times exceed max time.'</span>)
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> min(restrictTime &lt; 0)
                    disp(<span class="string">'varargin{2}: times start at 0.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                restrictTime = [min(t) max(t)];
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 4
                <span class="keyword">if</span> ~iscell(varargin{3})
                    error(<span class="string">'Wrong format for varargin{3}.'</span>)
                <span class="keyword">end</span>
                plotString2 = varargin{3}{2};
                rstart = varargin{3}{1}(1);
                rstop = varargin{3}{1}(2);
            <span class="keyword">end</span>

            frameInds = find(t &gt;= restrictTime(1) &amp; t &lt;= restrictTime(2));

            hold <span class="string">on</span>; axis <span class="string">ij</span>

            ind = obj.trajectoryIDs==tid;
            <span class="keyword">if</span> max(ind) &lt; 1
                error(<span class="string">'Could not find specified trajectory ID.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> isempty(obj.polyFits)
                error(<span class="string">'obj.polyFits is empty.'</span>)
            <span class="keyword">end</span>

            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};

            nframes = length(frameInds);
            x = cell(1,nframes);
            y = cell(1,nframes);

            q = linspace(0,1);

            <span class="keyword">for</span> k=1:nframes
                f = frameInds(k);
                px = fittedX(f,:);
                py = fittedY(f,:);
                x{k} = polyval(px,q);
                y{k} = polyval(py,q);
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 4
                [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
                <span class="keyword">for</span> k=1:nframes
                    xx = x{k};
                    yy = y{k};
                    f = frameInds(k);
                    radDist = R{f};
                    plot(xx,yy,plotString)
                    rind = radDist &gt;= rstart &amp; radDist &lt;= rstop;
                    plot(xx(rind),yy(rind),plotString2)
                    title([<span class="string">'t='</span> num2str(t(k)) <span class="string">' s'</span>])
                    pause(.1)
                    cla
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                <span class="keyword">for</span> k=1:nframes
                    plot(x{k},y{k},plotString)
                    title([<span class="string">'t='</span> num2str(t(k)) <span class="string">' s'</span>])
                    pause(.1)
                    cla
                <span class="keyword">end</span>
            <span class="keyword">end</span>
        <span class="keyword">end</span>

        <span class="keyword">function</span> plot_follicle_position_time_projection(obj, tid, varargin)
            <span class="comment">%</span>
            <span class="comment">%   plot_follicle_position_time_projection(obj, tid, varargin)</span>
            <span class="comment">%</span>
            <span class="comment">% tid: trajectory ID.  Only a single ID is allowed.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{1}: Plot color/symbol string.</span>
            <span class="comment">%</span>
            <span class="comment">% varargin{2}: Optional 2 x 1 vector giving starting and ending times (in seconds) to include in</span>
            <span class="comment">%               returned image, inclusive, starting with 0.</span>
            <span class="comment">%               Of format: [startTimeInSec endTimeInSec]. Can be empty ([]) to allow</span>
            <span class="comment">%               access to varargin{3}.</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="comment">%</span>
            <span class="keyword">if</span> numel(tid) &gt; 1
                error(<span class="string">'Only a single trajectory ID is alowed.'</span>)
            <span class="keyword">end</span>

            <span class="keyword">if</span> nargin &gt; 2
                plotString = varargin{1};
            <span class="keyword">else</span>
                plotString = <span class="string">'k-'</span>;
            <span class="keyword">end</span>

            [y,x,t] = obj.get_cached_follicle_coords(tid);

            <span class="keyword">if</span> nargin &gt; 3
                restrictTime = varargin{2};
                <span class="keyword">if</span> isempty(restrictTime)
                    restrictTime = [min(t) max(t)];
                <span class="keyword">elseif</span> restrictTime(2) &lt;= restrictTime(1)
                    error(<span class="string">'Invalid format for varargin{2}.'</span>)
                <span class="keyword">elseif</span> max(restrictTime) &gt; max(t)
                    disp(<span class="string">'Warning: varargin{2} exceeds max time; setting to max.'</span>)
                    restrictTime(restrictTime==max(restrictTime)) = max(t);
                    <span class="keyword">if</span> restrictTime(1)==restrictTime(2)
                        error(<span class="string">'varargin{2}: Both times exceed max time.'</span>)
                    <span class="keyword">end</span>
                <span class="keyword">elseif</span> min(restrictTime &lt; 0)
                    disp(<span class="string">'varargin{2}: times start at 0.'</span>)
                <span class="keyword">end</span>
            <span class="keyword">else</span>
                restrictTime = [min(t) max(t)];
            <span class="keyword">end</span>

            frameInds = find(t &gt;= restrictTime(1) &amp; t &lt;= restrictTime(2));
            hold <span class="string">on</span>; axis <span class="string">ij</span>
            plot(x(frameInds),y(frameInds),plotString)

        <span class="keyword">end</span>




    <span class="keyword">end</span>
    <span class="keyword">methods</span> <span class="comment">% Dependent property methods; cannot have attributes.</span>

        <span class="keyword">function</span> value = get.barPosClean(obj)
            <span class="comment">% Bar position cleaned up by processing to handle bar tracker errors/limitations.</span>

            <span class="keyword">if</span> isempty(obj.barPos)
                value = [];
            <span class="keyword">else</span>
                threshInMm = 2; <span class="comment">% Values exceeding this distance (in mm) from the</span>
                <span class="comment">% modal position will be set to the mode.</span>

                f = obj.barPos(:,1);
                x = round(obj.barPos(:,2));
                y = round(obj.barPos(:,3));
                ymode = mode(y);
                xmode = mode(x);

                ind = abs((y-ymode)/obj.pxPerMm) &gt; threshInMm;

                <span class="comment">% Replace outliers with mode. Note that this mode</span>
                <span class="comment">% has been rounded to the nearest pixel, whereas original</span>
                <span class="comment">% data in obj.barPos was sub-pixel resolution.</span>
                y(ind) = ymode;
                x(ind) = xmode;

                value = [f x y];
            <span class="keyword">end</span>
        <span class="keyword">end</span>

    <span class="keyword">end</span>

<span class="keyword">end</span>
</pre><p class="footer"><br>
      Published with MATLAB&reg; 7.14<br></p></div><!--
##### SOURCE BEGIN #####
classdef WhiskerSignalTrial < handle
    %
    %
    %   WhiskerSignalTrial < handle
    %
    % A class that deals with polynomial fits to tracked whisker (x,y) data.
    % The original (x,y) data are not preserved in WhiskerSignalTrial.
    %
    % DHO, 8/08.
    %
    %
    properties
        trialNum = [];
        trialType = NaN;
        whiskerNames = {};  % whiskerNames and trajectoryIDs must be of same length
        trajectoryIDs = []; % with matching elements.
        framePeriodInSec = 0.002;
        mouseName = '';
        sessionName = '';
        trackerFileName = '';
        
        % polyFits: Inherited from WhiskerTrial.
        % Cell array of length length(trajectoryIDs), of format:
        % {{XPolyCoeffs_tid0, YPolyCoeffs_tid0},...,{XPolyCoeffs_tidN, YPolyCoeffs_tidN}};
        polyFits = {};
        
        polyFitsROI = {}; % polyFitsROI: Inherited from WhiskerTrial.
                          % Same format as polyFits but polynomials are fitted only to a 
                          % constant region of arc length, and in addition to x and y coefficients
                          % there is stored the "q" values, i.e. the points along the normalized full
                          % whisker ([0,1]) that the ROI fitting begins,as well as the two corresponding
                          % values in units of pixels.  We store both for speed later. If a mask will be specified to define
                          % the arc-length origin it must be applied prior to populating polyFitsROI.
                          % Populated by method fit_polys_roi().

        % polyFitsMask:
        % Cell array of length length(trajectoryIDs), of format:
        %
        % There is generally a noisy edge to the tracked
        % whiskers on the side of whisker pad, which can interfere
        % with proper measurement of radial distances. For each whisker
        % for each trial, can specify here a polynomial in image coordinate
        % space to "mask out" the noisy edge. That is, radial distance for
        % purposes of mean theta and mean kappa measurements will be measured starting
        % at the intersection of the tracked whisker with this masking polynomial
        % if the whisker in fact crosses the masking polynomial. I.e., the radial
        % distance is r_new = r - r_intersection where r_new is the
        % new radial distance used in mean theta and mean kappa measurements, r is the
        % original radial distance, and r_intersection is the point of intersection
        % between the fitted whisker and the masking polynomial. If there is no intersection,
        % then r_new = r.  Also, if polyFitsMask is empty (or is empty for a given whisker)
        % then r_new = r.
        %
        % Ultimately, may want to do this separately for every frame, perhaps after
        % face tracking.
        %
        % Polynomials can be of any order, and are reconstructed based on the number
        % of coefficients.
        % If polyFitsMask{k}{1} and polyFitsMask{k}{2} are NxM matrices where
        % M is the polynomial degree + 1 and N is the number of frames, then each frame
        % has its own mask. For instance, this could be used after face tracking.
        % If instead polyFitsMask{k}{1} and polyFitsMask{k}{2} are 1xM vectors
        % where M is the polynomial degree + 1, then the same mask is used for all
        % frames.
        %         polyFitsMask = {{[25 120],[157.5 31.5]},{[25 120],[157.5 31.5]},{[25 120],[157.5 31.5]}};
        polyFitsMask = {};
        
        %   maskTreatment: String describing treatment of mask. Or, can be cell array
        %                   of strings, of same length as obj.trajectoryIDs and with
        %                   matching entries, in order to set maskTreatment differently
        %                   for different trajectory IDs.
        %               Values: 'none', 'mask', 'maskNaN'.
        %                   none: Ignore the mask.
        %                   mask: Subtract from each radial distance in R
        %                      the radial distance at the intersection of
        %                      each fitted whisker with the mask.  If there is
        %                      no intersection for a given whisker, make no change
        %                      in the radial distance measurement: i.e. 0 is still
        %                      at the end. If obj.polyFitsMask is empty ({}), make
        %                      no change.
        %                   maskNaN: Same as mask except that if the whisker does
        %                      not intersect the mask in a given frame, set all its
        %                      values in R to NaN.
        maskTreatment = 'maskNaN'; % Alternatively, {'maskNaN','none','mask'} to set three (or more)
        % different trajectories to have three (or more) different treatments.
        
        kappa = {}; % Can always recompute from polyFits and q, but cache for speed.
        theta = {}; % Can always recompute from polyFits and q, but cache for speed.
        follicleExtrapDistInPix = 0; % Sets extrapolated distance past end of whisker, or past intersection of whisker 
                                     % and mask if a mask is defined, at which follicle is estimated to be. Is not used until
                                     % recompute_cached_follicle_coords() is called.  
        follicleCoordsX = {}; % Can always recompute, but cache for speed.
        follicleCoordsY = {};
        barPos = []; %  Inherited from WhiskerTrial. [frameNum XPosition YPosition]
        barPosOffset = []; % [x y], either 1X2 or nframesX2
        barRadius = []; % Inherited from WhiskerTrial.  In pixels. Must be radius of bar tracked by the bar tracker.
        time = {};
        pxPerMm = 22.68; %  Inherited from WhiskerTrial, but give default value.
        faceSideInImage = 'top'; % Inherited from WhiskerTrial, but give default value.
        % Can be: 'top', 'bottom', 'left','right'.
        % May need to make this a cell array of strings, one per trajectory ID
        % to handle case of tracked whiskers on both sides of head.
        protractionDirection = 'rightward';  % Inherited from WhiskerTrial, but give default value.
                                            % Can be: 'downward','upward','rightward','leftward'.

        useFlag = 1;
    end
    
    properties (Dependent = true)
        barPosClean % Bar position after processing to clean up bar tracker errors/limitations.
    end
    
    methods (Access = public)
        function obj = WhiskerSignalTrial(w, varargin)
            %
            % USAGE:
            %
            %   obj = WhiskerSignalTrial(w)
            %   obj = WhiskerSignalTrial(w, 'polyRoiInPix',[roiMin, roiMax])
            %   obj = WhiskerSignalTrial(w, 'polyRoiInPix',{[trajectoryIDs],[roiMin1, roiMax1], ...
            %                                     [roiMin2, roiMax2], ...
            %                                     [roiMin3, roiMax3], ...
            %                                     [roiMinN, roiMaxN]})
            %
            % INPUTS:
            %   w: a WhiskerTrial object.
            %
            %   Optional argument polyRoiInPix:
            %       Sets arc-length limits (in pixels) on which to perform secondary curve fitting.
            %       This argument can be given in two forms:
            %           (1) an 1x2 vector that gives the ROI for *all* whiskers; or
            %           (2) a cell array where first element is a vector of trajectory IDs
            %               (of length N) and subsequent elements comprise N 1x2 vectors
            %               giving ROIs for the trajectory IDs specified in the first
            %               element (respectively).
            %       Limits are inclusive.
            %   
            %   If WhiskerSignalTrial(w) is called without 'polyRoiInPix'
            %   argument, and w.polyFitsROI is empty (i.e.,
            %   fit_polys_roi() method of WhiskerTrial w was not called earlier), then
            %   an error is given.  A WhiskerSignalTrial requires
            %   polynomials to be fitted to the whiskers.
            %
            %
            p = inputParser;
            p.addOptional('w', @(x) isa(x,'Whisker.WhiskerTrial'));                      
            p.addParamValue('polyRoiInPix', NaN); 
            p.parse(varargin{:});
            
            if nargin==0
                return
            end
            
            if isempty(w.polyFitsROI) && any(isnan(p.Results.polyRoiInPix))
                error(['If ''fit_polys_roi()'' has not already been called on ' ...
                    'WhiskerSignalTrial argument, then argument ''polyRoiInPix'' must be given.'])
            end

            if ~iscell(p.Results.polyRoiInPix) % Single ROI given; not specified individually for different trajectories.
                tidList = w.trajectoryIDs;
                roiAll = cell(1,length(tidList));
                % Copy ROI for each trajectory:
                for k=1:length(roiAll)
                    roiAll{k} = p.Results.polyRoiInPix;
                end
            else
                tidList = p.Results.polyRoiInPix{1};
                roiAll = p.Results.polyRoiInPix(2:end);
            end
            
            if length(tidList) ~= length(roiAll)
                error(['When given as a cell array, the first element of argument ''polyRoiInPix must be 1xN vector of trajectory IDs' ...
                    'and subsequent elements must comprise N 1x2 vectors giving the ROI for each trajectory.']);
            end
            
            if length(tidList) ~= length(w.trajectoryIDs)
                error('Number of trajectory IDs specified in varagin{1} does not match number of trajectory IDs in WhiskerTrial argument w.')
            end
            
            obj.trialNum = w.trialNum;
            obj.trialType = w.trialType;
            obj.whiskerNames = w.whiskerNames;
            obj.trajectoryIDs = w.trajectoryIDs;
            obj.framePeriodInSec = w.framePeriodInSec;
            obj.mouseName = w.mouseName;
            obj.sessionName = w.sessionName;
            obj.trackerFileName = w.trackerFileName;
            obj.faceSideInImage = w.faceSideInImage;
            obj.protractionDirection = w.protractionDirection;
            obj.pxPerMm = w.pxPerMm;
            obj.barPos = w.barPos;
            obj.barRadius = w.barRadius;
            obj.barPosOffset = w.barPosOffset;  
            obj.polyFitsMask = w.polyFitsMask;
            
            ntraj = length(obj.trajectoryIDs);
            
            obj.theta = cell(1,ntraj);
            obj.kappa = cell(1,ntraj);
            obj.time = cell(1,ntraj);
            
            for k=1:ntraj
                tid = obj.trajectoryIDs(k);
                ind = find(tidList==tid);
                if numel(ind) ~= 1
                    error('Trajectory either not found or found multiple times; argument varargin{1} must be incorrect.')
                end
                
                disp(['Fitting polys for TID = ' int2str(tid)])
                
                if ~isnan(roiAll{ind})
                    w.fit_polys_roi(roiAll{ind});
                end
                
                obj.polyFits = w.polyFits; % Put this here so that if WhiskerTrial had empty polyFits property
                                            % before calling w.mean_theta_and_kappa, it will now be transferred
                                            % to WhiskerSignalTrial.
                obj.polyFitsROI = w.polyFitsROI;
                obj.time{k} = w.get_time(tid);

            end
        end
        
        function obj = recompute_cached_mean_theta_kappa(obj, varargin)
            %
            %  obj = recompute_cached_mean_theta_kappa(obj, varargin)
            %
            % Recompute obj.theta, obj.kappa, and obj.time.
            %
            %   obj = recompute_cached_mean_theta_kappa(obj)
            %   obj = recompute_cached_mean_theta_kappa(obj, [xmin_position, xmax_position, xmin_curv, xmax_curv])
            %   obj = recompute_cached_mean_theta_kappa(obj, {[trajectoryIDs],[xmin_position1, xmax_position1, xmin_curv1, xmax_curv1], ...
            %                                     [xmin_position2, xmax_position2, xmin_curv2, xmax_curv2], etc})
            %
            %
            %   varargin{1}: pixel x-limits on which compute position and curvature.
            %       Sets an x-dimension ROI. This argument can be given in two forms:
            %           (1) an 1x4 vector that gives x-coordinates for *all* whiskers; or
            %           (2) a cell array where first element is a vector of trajectory IDs
            %               (of length N) and subsequent elements comprise N 1x4 vectors
            %               giving x-coordinates for the trajectory IDs specified in the first
            %               element (respectively).
            %
            %  UPDATE DESCRIPTION OF LIMITS WITH FOLLOWING:
            %   radial_window_kappa: 2x1 vector giving arc length region of whisker to
            %   average over for mean kappa measurment, in format [startDistance stopDistance].
            %   Values are inclusive and in units of pixels. If empty ([]), averages over
            %   the whole whisker.
            %
            %   radial_window_theta: 2x1 vector giving arc length region of whisker to
            %   average over for mean kappa measurment, in format [startDistance stopDistance].
            %   Values are inclusive and in units of pixels. If empty ([]), averages over
            %   the whole whisker, which is not likely useful for theta.
            %
            if nargin > 2
                error('Too many input arguments.')
            end
            if nargin==1
                tidList = obj.trajectoryIDs;
                XValLimsAll = cell(1,length(tidList)); % If no x-coordinates given for region of interest, all elts will be left empty.
            else
                xroi = varargin{1};
                if ~iscell(xroi) % Single set of x-coordinates given; not specified individually for different trajectories.
                    tidList = obj.trajectoryIDs;
                    XValLimsAll = cell(1,length(tidList));
                    % Copy single set of x-coordinates for each trajectory:
                    for k=1:length(XValLimsAll)
                        XValLimsAll{k} = xroi;
                    end
                else
                    tidList = xroi{1};
                    XValLimsAll = xroi(2:end);
                end
            end
            
            if length(tidList) ~= length(XValLimsAll)
                error(['First element of varargin{1} must be 1xN vector of trajectory IDs' ...
                    'and subsequent elements must comprise N 1x4 vectors giving x-coordinates']);
            end
            
            if length(tidList) ~= length(obj.trajectoryIDs)
                error('Number of trajectory IDs specified in varagin{1} does not match number of trajectory IDs in WhiskerTrial argument w.')
            end
            
            ntraj = length(obj.trajectoryIDs);
            
            obj.theta = cell(1,ntraj);
            obj.kappa = cell(1, ntraj);
            
            for k=1:ntraj
                tid = obj.trajectoryIDs(k);
                ind = find(tidList==tid);
                if numel(ind) ~= 1
                    error('Trajectory either not found or found multiple times; argument varargin{1} must be incorrect.')
                end
                XValLims = XValLimsAll{ind};
                if isempty(XValLims)
                    XValLimsPosition = [];
                    XValLimsCurv = [];
                else
                    XValLimsPosition = XValLims(1:2);
                    XValLimsCurv = XValLims(3:4);
                end
                
                disp(['Traj=' int2str(tid)])
                disp(['XValLimsPosition = ' num2str(XValLimsPosition)])
                disp(['XValLimsCurv = ' num2str(XValLimsCurv)])
                
                [t, theta, kappa] = obj.mean_theta_and_kappa(tid, XValLimsPosition, XValLimsCurv);
                
                obj.theta{k} = theta;
                obj.kappa{k} = kappa;
            end
            
        end
        
        function obj = recompute_cached_follicle_coords(obj, extrap_distance, varargin)
            %
            %  obj = recompute_cached_follicle_coords(obj, extrap_distance, varargin)
            %  obj = recompute_cached_follicle_coords(obj, extrap_distance)
            %  obj = recompute_cached_follicle_coords(obj, extrap_distance, tidList)
            %  obj = recompute_cached_follicle_coords(obj, extrap_distance, tidList, roi)
            %
            % Recomputes obj.follicleCoords.
            %
            %  INPUTS:
            %
            %   extrap_distance: The distance in units of pixels
            %        to extrapolate the whisker in order to get the
            %        (x,y) coordinates of the follicle. Extrapolation is
            %        based on the angle theta at the base of the whisker
            %        (radial distance = 0) if no mask is defined or if the
            %        whisker does not cross the mask.  Otherwise
            %        extrapolation is based on theta at the intersection of
            %        the whisker and the mask.
            %
            %   varargin{1}: Optional vector of trajectoryIDs. If varargin{1}
            %       is not given or is empty ([]), all trajectoryIDs in obj.trajectoryIDs
            %       are used. 
            %
            %   varargin{2}: Optional arc-length region of interest in which to
            %        fit a straight line to the whisker. This straight line is
            %        then extrapolated by extrap_distance to estimate the follicle
            %        position. Units of pixels.
            %        ** IMPORTANT**: Giving this varargin{2} argument
            %        fundamentally changes how the follicle position is estimated.
            %        If varargin{2} is *not* given, the most proximal theta value is used
            %        to set the direction of extrapolation.  See obj.get_follicle_coords().
            %
            %
            if nargin > 4
                error('Too many input arguments.')
            end
            if nargin > 3
                roi = varargin{2};
                fitLine = 1;
            else
                fitLine = 0;
            end
            if nargin==2
                tidList = obj.trajectoryIDs;
            else
                tidList = varargin{1};
                if isempty(tidList)
                    tidList = obj.trajectoryIDs;
                end
            end
            
            if extrap_distance <= 0 || length(extrap_distance) > 1
                error('Argument extrap_distance must be a positive scaler.')
            end
            
            obj.follicleExtrapDistInPix = extrap_distance; % Cache this argument in an object property.
                                                           % We need it later when computing moment of inertia.
            
            ntraj = length(obj.trajectoryIDs);
            obj.follicleCoordsX = cell(1,ntraj);
            obj.follicleCoordsY = cell(1,ntraj);
            if isempty(obj.time) % May have already been populated by recompute_cached_mean_theta_kappa()
                obj.time = cell(1,ntraj);
            end
            
            for k=1:length(tidList)
                tid = tidList(k);
                if ~ismember(tid,obj.trajectoryIDs)
                    error(['Trajectory ID ' int2str(tid) ' not found.'])
                end
                
                disp(['Computing follicle coordinates for TID = ' int2str(tid)])
                
                if fitLine==1
                    [y,x,t] = obj.get_follicle_coords(tid,extrap_distance,roi);
                else
                    [y,x,t] = obj.get_follicle_coords(tid,extrap_distance);
                end
                
                obj.follicleCoordsX{k} = x;
                obj.follicleCoordsY{k} = y;
                if isempty(obj.time{k}) % May have already been populated by recompute_cached_mean_theta_kappa()
                    obj.time{k} = t;
                end
                
            end
            
        end
        
        function tid = name2tid(obj, whisker_name)
            if ~ischar(whisker_name)
                error('Argument whisker_name must be a string.')
            end
            if numel(obj.whiskerNames) ~= numel(obj.trajectoryIDs)
                error('This WhiskerSignalTrial does not have matching whiskerNames and trajectoryIDs.')
            end
            tid = obj.trajectoryIDs( strmatch(whisker_name, obj.whiskerNames) );
        end
        
        function whisker_name = tid2name(obj, trajectory_id)
            if ~isnumeric(trajectory_id)
                error('Argument trajectory_id must be an integer.')
            end
            if numel(trajectory_id) > 1
                error('Only one trajectory_id is allowed.')
            end
            whisker_name = obj.whiskerNames(obj.trajectoryIDs==trajectory_id);
        end
        
        function  [pkVal,pkTime,pkBinarySignal] = get_whisk_peaks(obj,tid)
            %
            %   [pkVal,pkTime,pkBinarySignal] = get_whisk_peaks(obj,tid)
            %
            %
            %
            [y,t] = obj.get_position(tid);
            thresh = .01; % Should make argument. ***
            
            bandPassCutOffsInHz = [10 25];
            sampleRate = 500; % Should read from data.***
            W1 = bandPassCutOffsInHz(1) / (sampleRate/2);
            W2 = bandPassCutOffsInHz(2) / (sampleRate/2);
            [b,a]=butter(2,[W1 W2]);
            
            y = filtfilt(b,a,y);
            
            [pkVal,pkInd] = Whisker.lmax(y,0);
            
            ind = abs(pkVal) > thresh;
            pkVal = pkVal(ind);
            pkInd = pkInd(ind);
            
            pkTime = t(pkInd);
            
            pkBinarySignal = zeros(size(t));
            pkBinarySignal(pkInd) = 1;
        end
        
        function [f,Y] = get_FFT_position(obj,tid)
            %
            %   [f,Y] = get_FFT_position(obj,tid)
            %
            %
            Fs = 1 / obj.framePeriodInSec;
            [y,t] = obj.get_position(tid);
            
            % Check if frames are evenly spaced. If not, must interpolate theta for
            % missing frames prior to spectral analysis:
            frames = t ./ obj.framePeriodInSec;
            if length(unique(diff(frames))) > 1
                newframes = min(frames):max(frames);
                y = interp1(frames,y,newframes,'linear');
            end
            
            L = length(y);
            % Mean-subtract signal to eliminate DC term of transform:
            y = y - mean(y);
            NFFT = 2^nextpow2(L);
            %             h=hamming(L,'periodic')';
            %             y = y.*h;
            Y = fft(y,NFFT)/L;
            Y = 2*abs(Y(1:NFFT/2));
            f = Fs/2*linspace(0,1,NFFT/2);
        end
        
        function r = get_spectral_power_band_position(obj,tid,band)
            %
            %   r = get_spectral_power_band_position(obj,tid,band)
            %
            % band: [minFreqInclusive maxFreqInclusive]
            %
            [f,Y] = get_FFT_position(obj,tid);
            ind = f>=band(1) & f<=band(2);
            if isempty(ind)
                error('Invalid frequency band')
            end
            r = sum(Y(ind));
        end
        
        function r = curvatureDot(obj,varargin)
            %
            %   r = curvatureDot(obj,varargin)
            %
            % varargin{1}: vector of trajectory IDs.
            %
            % If only a single trajectory is specified, r is a vector.
            % If multiple trajectories are specified, r is a cell array
            % of vectors.
            %
            if nargin > 1
                tid = varargin{1};
            else
                tid = obj.trajectoryIDs;
            end
            if isempty(tid)
                tid = obj.trajectoryIDs;
            end
            
            ntraj = length(tid);
            if ntraj > 1
                r = cell(1,ntraj);
                for k=1:ntraj
                    ind = obj.trajectoryIDs==tid(k);
                    if max(ind) < 1
                        error('Trajectory ID was not found.')
                    end
                    t = obj.time{ind};
                    r{k} = [0 diff(obj.kappa{ind})] ./ [0 diff(t)];
                end
            else
                ind = obj.trajectoryIDs==tid;
                if max(ind) < 1
                    error('Trajectory ID was not found.')
                end
                t = obj.time{ind};
                r = [0 diff(obj.kappa{ind})] ./ [0 diff(t)];
            end
        end
        
        function [y,t] = get_position(obj,tid,varargin)
            %
            %   [y,t] = get_position(obj,tid,varargin)
            %
            % tid: Trajectory ID.
            %
            % varargin{1}: Optional smoothing span, in frames.
            %               If not specified there is no smoothing. Should be
            %               an odd number (see 'help smooth').
            %
            %
            % Returns angle with respect to y-axis of coordinate plane
            % in which slope is computed (i.e., of the high-speed video
            % image). Whisker angle is with respect to mouse midline if
            % y-axis of image is parallel with mouse midline.
            %
            % If a *decrease* in slope in image coordinates cooresponds to
            % whisker protraction, then this function returns increasing
            % angles during protraction.
            %
            % Angle is 0 deg when whisker is perpendicular to midline,
            % increases to +90 deg with protraction all the way to parallel
            % to the midline, and decreases to -90 deg with retraction all
            % the way to the midline.
            %
            %
            
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            t = obj.time{ind};
            y = obj.theta{ind};
            
            if nargin > 2
                span = varargin{1};
                if span < 3
                    error('Smoothing window in varargin{2} should be an odd number > 3.')
                end
                if mod(span,2)==0
                    disp('Smoothing window in varargin{2} should be an odd number. Smooth() will round it.')
                end
                % Check if frames are evenly spaced. If not, must interpolate theta for
                % missing frames prior to applying a moving average. Will do that, then
                % take only smoothed theta values at the original (non-interpolated)
                % frames.
                frames = t ./ obj.framePeriodInSec;
                if length(unique(diff(frames))) > 1
                    newframes = min(frames):max(frames);
                    newy = interp1(frames,y,newframes,'linear');
                    yy = smooth(newy,span,'moving')';
                    y = interp1(newframes,yy,frames,'linear'); % could use ismember instead
                else
                    y = smooth(y,span,'moving')';
                end
                % Sanity check:
                if length(y) ~= length(t)
                    error('y and t are of unequal lengths.')
                end
                
            end
            
        end
        
        function [y,t] = get_mean_position(obj)
            %
            %   [y,t] = get_mean_position(obj)
            %
            %   y is the ***mean position of all whiskers*** (tids) in trial.
            %   This is for use, e.g., in determining whether there is overall
            %   whisking after fully-automated tracking.
            %
            % Returns angle of average whisker with respect to y-axis of coordinate plane
            % in which slope is computed (i.e., of the high-speed video
            % image). Whisker angle is with respect to mouse midline if
            % y-axis of image is parallel with mouse midline.
            %
            % If a *decrease* in slope in image coordinates cooresponds to
            % whisker protraction, then this function returns increasing
            % angles during protraction.
            %
            % Angle is 0 deg when whisker is perpendicular to midline,
            % increases to +90 deg with protraction all the way to parallel
            % to the midline, and decreases to -90 deg with retraction all
            % the way to the midline.
            %
            %
            T = cell2mat(obj.time); Y = cell2mat(obj.theta);
            r = Shared.tapply([T' Y']);
            t = r(:,1); y = r(:,2);
        end
        
        function [th,t] = get_fitted_line_angle_in_roi(obj,tid,roi)
            %
            %    [th,t] = get_fitted_line_angle_in_roi(obj,tid,roi)
            %
            %  INPUTS:
            %
            %   tid: Trajectory ID.
            %
            %   roi: Arc-length region of interest in which to
            %        fit a straight line to the whisker. In units of pixels.
            %        The location of arc-length 0 depends on the mask settings.
            %        See documentation for object property maskTreatment.
            %
            %   RETURNS:
            %
            %   th: Whisker angle, theta, in degrees. Angle of 0 means that
            %       the whisker is parallel to the medial-lateral axis.
            %       Protraction corresponds to increasing angle.
            %       The value of obj.faceSideInImage must be set correctly to
            %       get correct angles from this method.
            %
            if numel(roi) ~= 2
                error('Argument roi must be a 2-element vector giving an arc-length ROI.')
            elseif roi(2) < roi(1)
                error('Argument roi  must give an arc-length ROI in format: [startInPix stopInPix].')
            end
            
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Could not find specified trajectory ID.')
            end
            
            if isempty(obj.polyFits)
                error('obj.polyFits is empty.')
            end
            
            if ~ischar(obj.faceSideInImage)
                error('(x,y) coordinate specification of face location not yet implemented.')
            end
            
            t = obj.get_time(tid);
            
            if all(isnan(t))
                disp(['All time values for trajectoryID=' int2str(tid) ' are NaN; perhaps '...
                    'nothing is tracked for this trial. Returning NaN.'])
                th = NaN;
                t = NaN;
                return
            end
            
            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
            rind = cellfun(@(x) find(x >= roi(1) & x <= roi(2)), R,'UniformOutput',false);
            

            nframes = length(t);
            
            th = zeros(1,nframes);
            
            q = linspace(0,1);
            
            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};
            
            for k=1:nframes
                %                 disp(['Frame=' int2str(k)])
                px = fittedX(k,:);
                py = fittedY(k,:);
                
                xall = polyval(px,q);
                yall = polyval(py,q);
                
                % If maskTreatment property is set to 'maskNaN', and the whisker
                % does not cross the mask, then all the radial distance values in R
                % for that whisker for that frame will be set to NaN.  In that case,
                % there will be an empty element in rind.  Propagate the NaN here:
                if isempty(rind{k})
                    th(k) = NaN;
                    continue
                end
                
                x = xall(rind{k});
                y = yall(rind{k});
                
                if numel(x) < 2 || numel(y) < 2
                    th(k) = NaN;
                    continue
                end
                
                if strcmp(obj.faceSideInImage,'right') || strcmp(obj.faceSideInImage,'left')
                    if numel(unique(x)) < 2
                        disp('Found whisker at either +180 deg or -180 deg; ambiguousREPLACE_WITH_DASH_DASHsetting to NaN')
                    end
                end
                
                if strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'upward') %
                    p = polyfit(x,y,1);
                    th(k) = atand(p(1));
                elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'downward') %
                    p = polyfit(x,y,1);
                    th(k) = -atand(p(1));
                elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'upward') %
                    p = polyfit(x,y,1);
                    th(k) = -atand(p(1));
                elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'downward') %
                    p = polyfit(x,y,1);
                    th(k) = atand(p(1));
                elseif strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'rightward') % 
                    p = polyfit(y,x,1);
                    th(k) = atand(p(1));
                elseif strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'leftward') %
                    p = polyfit(y,x,1);
                    th(k) = -atand(p(1));
                elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'rightward') %
                    p = polyfit(y,x,1);
                    th(k) = -atand(p(1));
                elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'leftward') %
                    p = polyfit(y,x,1);
                    th(k) = atand(p(1));
                else
                    error('Invalid value of obj.faceSideInImage.')
                end
            end
            
            ind = isinf(th);
            if sum(ind) > 0
                disp('Found frames with whisker at either +180 deg or -180 deg; ambiguousREPLACE_WITH_DASH_DASHsetting to NaN')
                th(ind) = NaN;
            end
            
        end
        
        function [y,x,t] = get_follicle_coords(obj,tid,extrap_distance,varargin)
            %
            %    [y,x,t] = get_follicle_coords(obj,tid,extrap_distance,varargin)
            %
            %  INPUTS:
            %
            %   tid: Trajectory ID.
            %
            %   extrap_distance: The distance in units of pixels
            %        to extrapolate the whisker in order to get the
            %        (x,y) coordinates of the follicle. Extrapolation is
            %        based on the angle theta at the base of the whisker
            %        (radial distance = 0) if no mask is defined or if the
            %        whisker does not cross the mask.  Otherwise
            %        extrapolation is based on theta at the intersection of
            %        the whisker and the mask.
            %
            %   varargin{1}: Optional arc-length region of interest in which to
            %        fit a straight line to the whisker. This straight line is
            %        then extrapolated by extrap_distance to estimate the follicle
            %        position. Units of pixels.
            %        ** IMPORTANT**: Giving this varargin{1} argument
            %        fundamentally changes how the follicle position is estimated.
            %        If varargin{1} is *not* given, the most proximal theta value is used
            %        (as described above) to set the direction of extrapolation.
            %
            %
            %  RETURNS:
            %
            % y: The y coordinate in image pixels of the follicle for each
            %    time point (i.e. frame).
            %
            % x: The x coordinate in image pixels of the follicle for each
            %    time point.
            %
            % t: The time of each observation in x,y.
            %
            %
            npoints = 100;  % Number of points to use in reconstructing whisker from fitted polynomials.
                            % Sets the resolution at which the follicle coordinates can be estimated when.
                            % A higher value is better but runs more slowly. Doesn't have any effect unless
                            % a mask is being used. 
            if nargin < 4
                fitLine = 0;
            else
                fitLine = 1;
                roiLine = varargin{1};
                if numel(roiLine) ~= 2
                    error('varargin{1} must be a 2-element vector giving an arc-length ROI.')
                elseif roiLine(2) < roiLine(1)
                    error('varargin{1} must give an arc-length ROI in format: [startInPix stopInPix].')
                end
            end
            
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Could not find specified trajectory ID.')
            end
            
            if isempty(obj.polyFits)
                error('obj.polyFits is empty.')
            end
            
%             if all(isnan(obj.theta{ind}))
%                 disp(['All theta values for trajectoryID=' int2str(tid) ' are NaN; perhaps '...
%                     'nothing is tracked for this trial. Setting face follicle coordinates to NaN.'])
%                 x = NaN;
%                 y = NaN;
%                 t = NaN;
%                 return
%             end
            
            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid,npoints);
            rind = cellfun(@(x) find(x==0), R,'UniformOutput',false);
            emp = find(cellfun(@isempty, rind));
            
            if fitLine==1 % Get angle based on line fitted to ROI.
                [th,t] = obj.get_fitted_line_angle_in_roi(tid,roiLine);
                if ~isempty(emp)
                    for q=1:length(emp)
                        th(emp(q)) = NaN;
                    end
                end
            else % Use theta at point where arc-length = 0.
                th = cellfun(@(x,y) x(y), THETA, rind,'UniformOutput',false);
                if ~isempty(emp)
                    % If maskTreatment property is set to 'maskNaN', and the whisker
                    % does not cross the mask, then all the radial distance values in R
                    % for that whisker for that frame will be set to NaN.  In that case,
                    % there will be an empty element in rind. Propagate the NaN here:
                    for q=1:length(emp)
                        th{emp(q)} = NaN;
                    end
                end
                th = cell2mat(th);
                t = obj.get_time(tid);
            end
            
            nframes = length(t);
            
            if nframes==0
                disp(['Number of frames for trajectoryID=' int2str(tid) ' is 0; perhaps '...
                    'nothing is tracked for this trial. Setting face follicle coordinates to NaN.'])
                x = NaN;
                y = NaN;
                t = NaN;
                return
            end

            x = zeros(1,nframes);
            y = zeros(1,nframes);
            
            q = linspace(0,1,npoints);
            
            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};
            
            for k=1:nframes
                %                 disp(['Frame=' int2str(k)])
                px = fittedX(k,:);
                py = fittedY(k,:);
                
                xall = polyval(px,q);
                yall = polyval(py,q);
                
                
                % If maskTreatment property is set to 'maskNaN', and the whisker
                % does not cross the mask, then all the radial distance values in R
                % for that whisker for that frame will be set to NaN.  In that case,
                % there will be an empty element in rind.  Propagate the NaN here:
                if isempty(rind{k})
                    x(k) = NaN;
                    y(k) = NaN;
                    % Alternatively, could just use (x,y,theta) values for point closest to
                    % face by uncommenting next two lines:
                    % xall(end);
                    % xall(end);
                else
                    x(k) = xall(rind{k});
                    y(k) = yall(rind{k});
                end
            end
            
            
            % Protraction means theta is increasing. 
            % Theta is 0 when perpendicular to the midline of the mouse.
            
            if strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'rightward')
                deltax = -extrap_distance*sind(th);
                deltay = -extrap_distance*cosd(th);
                
            elseif strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'leftward')
                deltax = extrap_distance*sind(th);
                deltay = -extrap_distance*cosd(th);
                
            elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'downward')
                deltax = -extrap_distance*cosd(th);
                deltay = -extrap_distance*sind(th);
            
            elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'upward')
                deltax = -extrap_distance*cosd(th);
                deltay = extrap_distance*sind(th);
            
            elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'upward')
                deltax = extrap_distance*cosd(th);
                deltay = extrap_distance*sind(th);
                
            elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'downward')
                deltax = extrap_distance*cosd(th);
                deltay = -extrap_distance*sind(th);            
                
            elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'rightward')
                deltax = -extrap_distance*sind(th);
                deltay = extrap_distance*cosd(th);  
            
            elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'leftward')
                deltax = extrap_distance*sind(th);
                deltay = extrap_distance*cosd(th);    
            else
                error('Invalid value of property ''faceSideInImage'' or ''protractionDirection''')
            end
            
            x = x + deltax;
            y = y + deltay;
        end
              
        function [y,t] = get_follicle_translation(obj,tid)
            %
            %    [y,t] = get_follicle_translation(obj,tid)
            %
            %  INPUTS:
            %
            %   tid: Trajectory ID.
            %
            %
            %  RETURNS:
            %
            % y: The distance the follicle has translated from the previous
            %    frame. Units of pixels.
            %
            % t: The time of each observation in y.
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Could not find specified trajectory ID.')
            end
            
            if isempty(obj.follicleCoordsX) || isempty(obj.follicleCoordsX)
                error(['obj.follicleCoordsX or obj.follicleCoordsY is empty. ' ...
                    'Must run obj.recompute_cached_follicle_coords before this method.'])
            end
            
            t = obj.get_time(tid);
            
            dx = [0 diff(obj.follicleCoordsX{ind})];
            dy = [0 diff(obj.follicleCoordsY{ind})];
            
            y = sqrt(dx.^2 + dy.^2);
        end
        
        function [y,x,t] = get_cached_follicle_coords(obj,tid)
            %
            %    [y,x,t] = get_cached_follicle_coords(obj,tid)
            %
            %  INPUTS:
            %
            %   tid: Trajectory ID.
            %
            %
            %  RETURNS:
            %
            % y: The y coordinate in image pixels of the follicle for each
            %    time point (i.e. frame).
            %
            % x: The x coordinate in image pixels of the follicle for each
            %    time point.
            %
            % t: The time of each observation in x,y.
            %
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Could not find specified trajectory ID.')
            end
            
            if isempty(obj.follicleCoordsX) || isempty(obj.follicleCoordsX)
                error(['obj.follicleCoordsX or obj.follicleCoordsY is empty. ' ...
                    'Must run obj.recompute_cached_follicle_coords before this method.'])
            end
            
            t = obj.get_time(tid);
            
            x = obj.follicleCoordsX{ind};
            y = obj.follicleCoordsY{ind};
        end
        
        function [y,t] = get_curvature(obj,tid)
            %
            %   [y,t] = get_curvature(obj,tid)
            %
            %   t: time in seconds.
            %   y: whisker curvature in units of pixels^(-1).
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            t = obj.time{ind};
            y = obj.kappa{ind};
        end
        
        function [y,t] = get_curvatureChange(obj,tid,varargin)
            %
            %   [y,t] = get_curvatureChange(obj,tid,varargin)
            %
            %   varargin{1}: Optional period to use for computing
            %       baseline curvature. Starts at 0 but user
            %       specifies endpoint in seconds. Default is 0.05 s.
            %
            %   t: time in seconds.
            %   y: whisker curvature change in units of pixels^(-1).
            %
            
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            t = obj.time{ind};
            y = obj.kappa{ind};
            
            if nargin > 2
                baselinePeriodEnd = varargin{1};
            else
                baselinePeriodEnd = 0.05;
            end
            
            baseline = mean(y(t<=baselinePeriodEnd));
            y = y-baseline;
        end
        
        function [y,t] = get_curvatureDot(obj,tid)
            %
            %   [y,t] = get_curvatureDot(obj,tid)
            %
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            t = obj.time{ind};
            y = obj.curvatureDot(tid);
        end
        
        function [y,t] = get_velocity(obj,tid,varargin)
            %
            %   [y,t] = get_velocity(obj,tid,varargin)
            %
            % Angular velocity in degrees per second.
            %
            % tid: Trajectory ID.
            %
            % varargin{1}: Optional smoothing window, in frames,
            %              **for position (theta) signal.** Velocity is not
            %              separately smoothed. May want to smooth theta to
            %              eliminate noise due to whisker tracking artifacts.
            %               If not specified there is no smoothing. Should be
            %               an odd number (see 'help smooth').
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            %             t = obj.time{ind};
            if nargin > 2
                [theta,t] = obj.get_position(tid,varargin{1});
            else
                [theta,t] = obj.get_position(tid);
            end
            y = [0 diff(theta)] ./ [0 diff(t)]; % in degrees/sec
        end
        
        function [y,t] = get_velocity_medfilt(obj,tid,varargin)
            %
            %   [y,t] = get_velocity_medfilt(obj,tid,varargin)
            %
            % Angular velocity in degrees per second, after filtering
            % position signal with a median filter.
            %
            % tid: Trajectory ID.
            %
            % varargin{1}: Optional smoothing window, in frames,
            %              **for position (theta) signal.** Velocity is not
            %              separately filtered. May want to filter theta to
            %              eliminate noise due to whisker tracking artifacts.
            %              Default is 3. Should be
            %               an odd number (see help medfilt1).
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            %             t = obj.time{ind};
            if nargin > 2
                span = varargin{1};
                if mod(span,2)==0
                    disp('Varargin{1}, should be odd; will be rounded down.')
                end
            else
                span = 3;
            end
            
            [theta,t] = obj.get_position(tid);
            
            % Check if frames are evenly spaced. If not, must interpolate theta for
            % missing frames prior to applying filter. Will do that, then
            % take only smoothed theta values at the original (non-interpolated)
            % frames.
            frames = t ./ obj.framePeriodInSec;
            if length(unique(diff(frames))) > 1
                newframes = min(frames):max(frames);
                newy = interp1(frames,theta,newframes,'linear');
                yy = medfilt1(newy,span)';
                y = interp1(newframes,yy,frames,'linear'); % could use ismember instead
            else
                y = medfilt1(theta,span);
            end
            % Sanity check:
            if length(y) ~= length(t)
                error('y and t are of unequal lengths.')
            end
            
            y = [0 diff(y)] ./ [0 diff(t)]; % in degrees/sec
        end
        
        function [y,t] = get_acceleration(obj,tid,varargin)
            %
            %   [y,t] = get_acceleration(obj,tid,varargin)
            %
            % Angular acceleration in degrees per second^2.
            %
            % tid: Trajectory ID.
            %
            % varargin{1}: Optional moving average smoothing window, in frames,
            %              **for position (theta) signal.** Acceleration is not
            %              separately smoothed. May want to smooth theta to
            %              eliminate noise due to whisker tracking artifacts.
            %               If not specified there is no smoothing. Should be
            %               an odd number (see 'help smooth').
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            %             t = obj.time{ind};
            
            if nargin > 2
                [velocity,t] = obj.get_velocity(tid,varargin{1});
            else
                [velocity,t] = obj.get_velocity(tid);
            end
            y = [0 diff(velocity)] ./ [0 diff(t)]; % in degrees/sec
        end
        
        function plot_whisker_angle(obj,tid,varargin)
            %
            %   plot_whisker_angle(obj,tid,varargin)
            %
            % tid: A single trajectory ID.
            %
            % varargin{1}: Optional plot color/symbol string specifier.
            %              Can be empty ([]) to allow access to varargin{2}.
            %
            % varargin{2}: Optional moving average smoothing window, in frames.
            %               If not specified there is no smoothing. Should be
            %               an odd number (see 'help smooth').
            %
            % If a *decrease* in slope in image coordinates cooresponds to
            % whisker protraction, then this function plots increasing
            % angles during protraction.
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            
            if nargin==2
                plotString = 'k.-';
                [y,t] = obj.get_position(tid);
            elseif nargin==3
                plotString = varargin{1};
                if isempty(plotString)
                    plotString = 'k.-';
                end
                [y,t] = obj.get_position(tid);
            elseif nargin==4
                plotString = varargin{1};
                if isempty(plotString)
                    plotString = 'k.-';
                end
                span = varargin{2};
                [y,t] = obj.get_position(tid,span);
            end
            
            plot(t,y,plotString);
            
            set(gca,'TickDir','out','box','off')
            xlabel('Sec')
        end
        
        function plot_whisker_curvature(obj,tid,varargin)
            %
            %   plot_whisker_curvature(obj,tid,varargin)
            %
            % varargin{1}: Optional plot color/symbol string specifier.
            %
            %   Plots whisker curvature (units of pixels^(-1)) against
            %   time (in seconds).
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            t = obj.time{ind};
            y = obj.kappa{ind};% * obj.pxPerMm;
            if nargin > 2
                plot(t,y, varargin{1});
            else
                plot(t,y, 'k.-');
            end
            set(gca, 'TickDir','out','box','off')
            xlabel('Sec')
        end
        
        function plot_whisker_curvatureDot(obj,tid,varargin)
            %
            %   plot_whisker_curvatureDot(obj,tid,varargin)
            %
            % varargin{1}: Optional plot color/symbol string specifier.
            %
            %
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            t = obj.time{ind};
            y = obj.curvatureDot(tid);
            if nargin > 2
                plot(t,y, varargin{1});
            else
                plot(t,y, 'k.-');
            end
        end
        
        function obj = set_mask_from_points(obj,tid,x,y)
            %
            % Sets obj.polyFitsMask in order
            % to create a mask defined by the points in x and y.
            %
            % tid: Trajectory ID. Can be a vector with multiple trajectory
            %       IDs. In this case all will be set to have same mask.
            %
            % x: Row vector of x coordinates to define mask.
            % y: Row vector of y coordinates to define mask.
            %
            % If N points are selected, mask will be the (N-1)-th
            % degree polynomial fit to the points for N < 6. For N >= 6
            % the polynomial will be 5-th degree.
            %
            qnum = length(x);
            if length(x) ~= length(y)
                error('Inputs x and y must be of equal length.')
            end
            
            % Make x, y row vectors:
            if size(x,1) > size(x,2)
                x = x';
            end
            if size(y,1) > size(y,2)
                y = y';
            end
            
            if qnum < 2
                error('Must define at least 2 points.')
            elseif qnum < 6
                polyDegree = qnum-1;
            else
                polyDegree = 5;
            end
            
            q = (0:(qnum-1))./(qnum-1); % [0,1]
            
            % polyfit() gives warnings that indicate that we don't need such a high degree
            % polynomials. Turn off.
            warning('off','MATLAB:polyfit:RepeatedPointsOrRescale');
            px = polyfit(q,x,polyDegree);
            py = polyfit(q,y,polyDegree);
            warning('on','MATLAB:polyfit:RepeatedPointsOrRescale');
            
            if isempty(obj.polyFitsMask)
                obj.polyFitsMask = cell(1,length(obj.trajectoryIDs));
            end
            
            for k=1:length(tid)
                ind = obj.trajectoryIDs==tid(k);
                if max(ind) < 1
                    error('Trajectory ID was not found.')
                end
                obj.polyFitsMask{ind} = {px,py};
            end
        end
        
        function obj = set_bar_offset(obj,dx,dy)
            %
            % obj = set_bar_offset(obj,dx,dy)
            %
            % dx: Number of pixels to offset bar center in x.
            % dy: Number of pixels to offset bar center in y.
            %
            %
            %
            if length(dx) ~= 1 || length(dy) ~= 1
                error('Arguments dx and dy must both be scaler.')
            end
            
            obj.barPosOffset = [dx dy];
            
            % Should also add capability to set different offsets for
            % different frames.
        end
        
        function plot_mask(obj,tid,varargin)
            %
            % Plots the polynomial mask defined by obj.polyFitsMask.
            %
            % tid: A single trajectory ID.
            %
            % varargin{1}: Plot symbol string, e.g., 'k-'.  A string
            %               that can be given as an argument to plot().
            %
            % varargin{2}: Tracked frame number, from 1 to the number of
            %        frames tracked. Not necessarily frame number from
            %        the original movie (unless all frames were tracked).
            %        If the mask is the same for all frames, this argument
            %        is ignored.
            %
            %
            %
            if isempty(obj.polyFitsMask)
                disp('obj.polyFitsMask is empty; nothing to plot.')
                return
            end
            
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Trajectory ID was not found.')
            end
            
            if isempty(obj.polyFitsMask{ind})
                disp(['obj.polyFitsMask for tid ' int2str(tid) 'is empty; nothing to plot.'])
                return
            end
            
            if length(tid) > 1
                error('Only a single trajectory ID allowed.')
            end
            
            if nargin > 4
                error('Too many input arguments.')
            end
            
            if nargin > 2
                plotString = varargin{1};
            else
                plotString = 'k-';
            end
            
            if nargin > 3
                frame = varargin{2};
                if frame > length(obj.time{ind})
                    error('varargin{2}, the frame number, exceeds the number of tracked frames.')
                end
            else
                frame = 1;
            end
            
            px = obj.polyFitsMask{ind}{1};
            py = obj.polyFitsMask{ind}{2};
            
            if size(px,1) > 1
                px = px(frame,:);
                py = py(frame,:);
            end
            
            q = linspace(0,1);
            
            x = polyval(px,q);
            y = polyval(py,q);
            
            plot(x,y,plotString,'LineWidth',2)
        end
        
        function [t,theta,kappa] = mean_theta_and_kappa(obj,tid,radial_window_theta,radial_window_kappa)
            %
            %  [t,theta,kappa] = mean_theta_and_kappa(obj,tid,radial_window_theta,radial_window_kappa)
            %
            %   The whisker is parameterized as c(q) = (x(q),y(q)), where q has length(x)
            %   and is in [0,1].
            %
            % INPUTS:
            %
            %   tid: Whisker trajectory ID.
            %
            %   radial_window_kappa: 2x1 vector giving arc length region of whisker to
            %   average over for mean kappa measurment, in format [startDistance stopDistance].
            %   Values are inclusive and in units of pixels. If empty ([]), averages over
            %   the whole whisker.
            %
            %   radial_window_theta: 2x1 vector giving arc length region of whisker to
            %   average over for mean kappa measurment, in format [startDistance stopDistance].
            %   Values are inclusive and in units of pixels. If empty ([]), averages over
            %   the whole whisker, which is not likely useful for theta.
            %
            %   For this function to work properly, object property 'radialDirection'
            %   must be correctly set.  See help Whisker.WhiskerTrial.set_radialDirection.
            %
            % RETURNS:
            %
            %   t:  Time in seconds corresponding to each frame.
            %
            %   theta: Angle of the line tangent to the whisker (i.e., to c(q)), averaged over
            %           radial distances (arc length) between and including radial_window_theta(1)
            %           and radial_window_theta(2).
            %
            %   kappa:  Signed curvature averaged over radials distances (arc length) between and including
            %           radial_window_kappa(1) and radial_window_kappa(2), for each frame.
            %           Units of 1/pixels. Abs(kappa(q)) is 1/X where X is
            %           the radius in pixels of the osculating circle at c(q).
            %
            %
            %
            
            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
            
            if isempty(radial_window_kappa)
                kappa = cellfun(@mean, KAPPA);
            else
                %                 kappa = cellfun(@(x,y) mean(x(y >= radial_window_kappa(1) & y <= radial_window_kappa(2))),KAPPA,R);
                nframes = length(R);
                kappa = nan(1,nframes);
                for k=1:length(R)
                    if ~isnan(R{k}(1))
                        kappa(k) = mean(KAPPA{k}( R{k} >= radial_window_kappa(1) & R{k} <= radial_window_kappa(2) ));
                    end
                end
            end
            
            
            if isempty(radial_window_theta)
                theta = cellfun(@mean, THETA);
            else
                %                 theta = cellfun(@(x,y) mean(x(y >= radial_window_theta(1) & y <= radial_window_theta(2))),THETA,R);
                nframes = length(R);
                theta = nan(1,nframes);
                for k=1:length(R)
                    if ~isnan(R{k}(1))
                        theta(k) = mean(THETA{k}( R{k} >= radial_window_theta(1) & R{k} <= radial_window_theta(2) ));
                    end
                end
            end
            
            t = obj.get_time(tid);
            
            % Interpolate to fill missing (NaN) values, arising for instance if there
            % weren't enough pixels to do curve fitting. NaN also arise if obj.maskTreatment
            % is set to 'maskNaN'.
            missing = isnan(kappa);
            if sum(missing)==length(kappa)
                error('Less than 2 non-NaN values for mean kappa timeseries. May be a bad mask, that no whiskers cross.')
            end
            kappa = interp1(t(~missing),kappa(~missing),t,'linear','extrap');
            
            missing = isnan(theta);
            if sum(missing)==length(theta)
                error('Less than 2 non-NaN values for mean theta timeseries. May be a bad mask, that no whiskers cross.')
            end
            theta = interp1(t(~missing),theta(~missing),t,'linear','extrap');
        end
        
%         function [y,t] = get_follicle_arc_length_position(obj,tid)
%             %
%             % [y,t] = get_follicle_arc_length_position(obj,tid)
%             %
%             % Fits polynomials to the the follicle x and y coordinates, parameterizing
%             % the path they take along the face as c(q) = (x(q),y(q)), where q is in [0,1]. 
%             % Arc length at each point along this path is then computed. For each frame
%             % the closest point on the curve to the follicle is determined. The arc-length
%             % location of this point is returned in r.
%             %
%             % obj.follicleCoordsX and obj.follicleCoordsY must be non-empty (i.e.
%             % obj.recompute_cached_follicle_coords() must have been called.
%             %
%             %
%             %
%             
%             
%             
%         end

        function [R,THETA,KAPPA,varargout] = arc_length_theta_and_kappa(obj,tid,varargin)
            %
            % [R,THETA,KAPPA] = arc_length_theta_and_kappa(obj,tid)
            % [R,THETA,KAPPA,Y,X] = arc_length_theta_and_kappa(obj,tid)
            % [R,THETA,KAPPA] = arc_length_theta_and_kappa(obj,tid,npoints)
            %
            %   The whisker is parameterized as c(q) = (x(q),y(q)), where q 
            %   is in [0,1].
            %
            %   For this function to work properly, object properties 'faceSideInImage'
            %   and 'imagePixelDimsXY' must be correctly set.
            %
            % INPUTS:
            %
            %   tid: Whisker trajectory ID.
            %
            %   varargin{1}: Optional, integer giving number of points (values of q) to 
            %        use in reconstructing each whisker. Default is 100 points.  
            %    
            %
            % RETURNS:
            %
            %   R:  A cell array where each element is the arc length, computed moving outward from
            %       whisker follicle along the whisker for a single frame. Units of pixels.
            %
            %   THETA: A cell array where each element theta is the angle of the line tangent to the
            %           whisker (i.e., to c(q)) at each value of q. In
            %           degrees.
            %
            %   KAPPA: A cell array where each element kappa is the signed curvature at each point
            %           on the whisker (i.e., for each value of q). Units of 1/pixels. Abs(kappa(q)) is 1/X where X is
            %           the radius in pixels of the osculating circle at c(q).
            %
            %   Optionally also:
            %
            %   X,Y: Cell arrays containing the x and y image (pixel) coordinates corresponding to the
            %        values in R, THETA, and KAPPA.
            %
            %
            %
            %   kappa(q) = (x'y'' - y'x'') / (x'^2 + y'^2)^(3/2)
            %   theta(q) = atand(y'/x')
            %   arc_length(q) = cumsum(sqrt(x'^2 + y'^2))
            %
            %
            if nargin < 3
                npoints = 100;
            else
                npoints = varargin{1};
                if isempty(npoints)
                    npoints = 100;
                end
            end
            
            ind = find(obj.trajectoryIDs == tid);
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            
            nframes = size(obj.polyFits{ind}{1},1);
            
            if isempty(obj.polyFits)
                error('obj.polyFits is empty.')
            end
            
            R = cell(1,nframes);
            THETA = cell(1,nframes);
            KAPPA = cell(1,nframes);
            
            if nargout>3
                X = cell(1,nframes);
                Y = cell(1,nframes);
            end
            
            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};
            
            q = linspace(0,1,npoints);
            
            for k=1:nframes
                
                px = fittedX(k,:);
                py = fittedY(k,:);
                
                pxDot = polyder(px);
                pxDoubleDot = polyder(pxDot);
                
                pyDot = polyder(py);
                pyDoubleDot = polyder(pyDot);
                
                xDot = polyval(pxDot,q);
                xDoubleDot = polyval(pxDoubleDot,q);
                
                yDot = polyval(pyDot,q);
                yDoubleDot = polyval(pyDoubleDot,q);
                
                dq = [0 diff(q)];
                
                % Arc length as a function of q, after integration below:
                R{k} = cumsum(sqrt(xDot.^2 + yDot.^2) .* dq); % arc length segments, in pixels, times dq.
                
                
                % Angle (in degrees) as a function of q:
                % Protraction means theta is increasing.
                % Theta is 0 when perpendicular to the midline of the mouse.
                if strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'rightward')
                    THETA{k} = atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'leftward')
                    THETA{k} = -atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'downward')
                    THETA{k} = atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'upward')
                    THETA{k} = -atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'upward')
                    THETA{k} = atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'downward')
                    THETA{k} = -atand(yDot ./ xDot);
                elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'rightward')
                    THETA{k} = -atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'leftward')
                    THETA{k} = atand(xDot ./ yDot);
                else
                    error('Invalid value of property ''faceSideInImage'' or ''protractionDirection''')
                end
                
                
                % Signed curvature as a function of q:
                KAPPA{k} = (xDot.*yDoubleDot - yDot.*xDoubleDot) ./ ((xDot.^2 + yDot.^2).^(3/2)); % SIGNED CURVATURE, in 1/pixels.
                %                 KAPPA{k} = abs(xDot.*yDoubleDot - yDot.*xDoubleDot) ./ ((xDot.^2 + yDot.^2).^(3/2)); % CURVATURE, in 1/pixels.
                
                if nargout>3
                    X{k} = polyval(px,q);
                    Y{k} = polyval(py,q);
                    varargout{1} = Y;
                    varargout{2} = X;
                end
            end
            
            % Apply any mask:
            if iscell(obj.maskTreatment)
                if length(obj.maskTreatment) ~= length(obj.trajectoryIDs)
                    error('obj.maskTreatment and obj.trajectoryIDs must have the same length and matching entries.')
                end
                mask_treatment = obj.maskTreatment{ind};
            else
                mask_treatment = obj.maskTreatment;
            end
            
            if strcmp(mask_treatment,'none')
                return
            end
            
            % If there is a polynomial mask specified (see documentation for
            % object property 'polyFitsMask') and varargin{1} is given, subtract from each element of
            % R the radial distance at the intersection, if any, of the fitted
            % whisker and the polynomial mask.
            if isempty(obj.polyFitsMask)
                return
            else
                pm = obj.polyFitsMask{ind};
                if isempty(pm)
                    return
                end
            end
            
            fittedXMask = obj.polyFitsMask{ind}{1};
            fittedYMask = obj.polyFitsMask{ind}{2};
            
            q = linspace(0,1,npoints);
            
            for k=1:nframes
                
                px = fittedX(k,:);
                py = fittedY(k,:);
                
                if size(fittedXMask,1) > 1
                    pxm = fittedXMask(k,:);
                    pym = fittedYMask(k,:);
                else
                    pxm = fittedXMask;
                    pym = fittedYMask;
                end
                
                C1 = [polyval(px,q); polyval(py,q)];
                C2 = [polyval(pxm,q); polyval(pym,q)];
                
                P = Whisker.InterX(C1,C2); % Find points where whisker and mask curves intersect. Slower but more
                                           % accurate version that isn't limited in resolution by the number of
                                           % points whisker and mask are evaluated at.
                if size(P,2) > 1   % Don't need for faster version, which handles this.
                    disp('Found more than 1 intersection of whisker and mask curves; using only first.')
                    P = P(:,1);
                end
                                           
%                 P = Whisker.InterXFast(C1,C2); % Find points where whisker and mask curves intersect. Much faster version
%                                                 % that is limited in resolution by the number of
%                                                 % points whisker and mask are evaluated at (i.e., by number of points in q).
                                                
                if isempty(P)
                    if strcmp(mask_treatment,'maskNaN')
                        R{k} = nan(size(R{k}));
                    end
                else
                    % Find at what q the whisker is at (P(1),P(2)), i.e., q s.t. x(q)=P(1),y(q)=P(2).
                    % Doesn't match exactly (maybe due to roundoff error), so find closest.
                    C = C1 - repmat(P,[1 size(C1,2)]);
                    err = sqrt(C(1,:).^2 + C(2,:).^2);
                    ind2 = err==min(err);
                    R{k} = R{k} - R{k}(ind2);
                end
            end
        end
        
        function [R,THETA,varargout] = arc_length_and_theta(obj,tid,varargin)
            % 
            % POINT OF THIS IS THAT IT'S FASTER THAN arc_length_theta_and_kappa when
            % KAPPA IS NOT NEEDED.****
            %
            % [R,THETA] = arc_length_theta_and_kappa(obj,tid)
            % [R,THETA,Y,X] = arc_length_theta_and_kappa(obj,tid)
            % [R,THETA] = arc_length_theta_and_kappa(obj,tid,npoints)
            %
            %   The whisker is parameterized as c(q) = (x(q),y(q)), where q 
            %   is in [0,1].
            %
            %   For this function to work properly, object properties 'faceSideInImage'
            %   and 'imagePixelDimsXY' must be correctly set.
            %
            % INPUTS:
            %
            %   tid: Whisker trajectory ID.
            %
            %   varargin{1}: Optional, integer giving number of points (values of q) to 
            %        use in reconstructing each whisker. Default is 100 points.  
            %    
            %
            % RETURNS:
            %
            %   R:  A cell array where each element is the arc length, computed moving outward from
            %       whisker follicle along the whisker for a single frame. Units of pixels.
            %
            %   THETA: A cell array where each element theta is the angle of the line tangent to the
            %           whisker (i.e., to c(q)) at each value of q. In
            %           degrees.
            %
            %
            %   Optionally also:
            %
            %   X,Y: Cell arrays containing the x and y image (pixel) coordinates corresponding to the
            %        values in R, THETA, and KAPPA.
            %
            %
            %
            %   kappa(q) = (x'y'' - y'x'') / (x'^2 + y'^2)^(3/2)
            %   theta(q) = atand(y'/x')
            %   arc_length(q) = cumsum(sqrt(x'^2 + y'^2))
            %
            %
            if nargin < 3
                npoints = 100;
            else
                npoints = varargin{1};
                if isempty(npoints)
                    npoints = 100;
                end
            end
            
            ind = find(obj.trajectoryIDs == tid);
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            
            nframes = size(obj.polyFits{ind}{1},1);
            
            if isempty(obj.polyFits)
                error('obj.polyFits is empty.')
            end
            
            R = cell(1,nframes);
            THETA = cell(1,nframes);
            
            if nargout>3
                X = cell(1,nframes);
                Y = cell(1,nframes);
            end
            
            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};
            
            q = linspace(0,1,npoints);
            
            for k=1:nframes
                
                px = fittedX(k,:);
                py = fittedY(k,:);
                
                pxDot = polyder(px);
                
                pyDot = polyder(py);
                
                xDot = polyval(pxDot,q);
                
                yDot = polyval(pyDot,q);
                
                dq = [0 diff(q)];
                
                % Arc length as a function of q, after integration below:
                R{k} = cumsum(sqrt(xDot.^2 + yDot.^2) .* dq); % arc length segments, in pixels, times dq.
                
                
                % Angle (in degrees) as a function of q:
                % Protraction means theta is increasing.
                % Theta is 0 when perpendicular to the midline of the mouse.
                if strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'rightward')
                    THETA{k} = atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'leftward')
                    THETA{k} = -atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'downward')
                    THETA{k} = atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'upward')
                    THETA{k} = -atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'upward')
                    THETA{k} = atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'downward')
                    THETA{k} = -atand(yDot ./ xDot);
                elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'rightward')
                    THETA{k} = -atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'leftward')
                    THETA{k} = atand(xDot ./ yDot);
                else
                    error('Invalid value of property ''faceSideInImage'' or ''protractionDirection''')
                end
                
                if nargout>3
                    X{k} = polyval(px,q);
                    Y{k} = polyval(py,q);
                    varargout{1} = Y;
                    varargout{2} = X;
                end
            end
            
            % Apply any mask:
            if iscell(obj.maskTreatment)
                if length(obj.maskTreatment) ~= length(obj.trajectoryIDs)
                    error('obj.maskTreatment and obj.trajectoryIDs must have the same length and matching entries.')
                end
                mask_treatment = obj.maskTreatment{ind};
            else
                mask_treatment = obj.maskTreatment;
            end
            
            if strcmp(mask_treatment,'none')
                return
            end
            
            % If there is a polynomial mask specified (see documentation for
            % object property 'polyFitsMask') and varargin{1} is given, subtract from each element of
            % R the radial distance at the intersection, if any, of the fitted
            % whisker and the polynomial mask.
            if isempty(obj.polyFitsMask)
                return
            else
                pm = obj.polyFitsMask{ind};
                if isempty(pm)
                    return
                end
            end
            
            fittedXMask = obj.polyFitsMask{ind}{1};
            fittedYMask = obj.polyFitsMask{ind}{2};
            
            q = linspace(0,1,npoints);
            
            for k=1:nframes
                
                px = fittedX(k,:);
                py = fittedY(k,:);
                
                if size(fittedXMask,1) > 1
                    pxm = fittedXMask(k,:);
                    pym = fittedYMask(k,:);
                else
                    pxm = fittedXMask;
                    pym = fittedYMask;
                end
                
                C1 = [polyval(px,q); polyval(py,q)];
                C2 = [polyval(pxm,q); polyval(pym,q)];
                
                P = Whisker.InterX(C1,C2); % Find points where whisker and mask curves intersect. Slower but more
                                           % accurate version that isn't limited in resolution by the number of
                                           % points whisker and mask are evaluated at.
                if size(P,2) > 1   % Don't need for faster version, which handles this.
                    disp('Found more than 1 intersection of whisker and mask curves; using only first.')
                    P = P(:,1);
                end
                                           
%                 P = Whisker.InterXFast(C1,C2); % Find points where whisker and mask curves intersect. Much faster version
%                                                 % that is limited in resolution by the number of
%                                                 % points whisker and mask are evaluated at (i.e., by number of points in q).
                                                
                if isempty(P)
                    if strcmp(mask_treatment,'maskNaN')
                        R{k} = nan(size(R{k}));
                    end
                else
                    % Find at what q the whisker is at (P(1),P(2)), i.e., q s.t. x(q)=P(1),y(q)=P(2).
                    % Doesn't match exactly (maybe due to roundoff error), so find closest.
                    C = C1 - repmat(P,[1 size(C1,2)]);
                    err = sqrt(C(1,:).^2 + C(2,:).^2);
                    ind2 = err==min(err);
                    R{k} = R{k} - R{k}(ind2);
                end
            end
        end
        
        function [R,THETA,KAPPA,varargout] = arc_length_theta_and_kappa_in_roi(obj,tid,varargin)
            %
            % [R,THETA,KAPPA] = arc_length_theta_and_kappa_in_roi(obj,tid)
            % [R,THETA,KAPPA,Y,X] = arc_length_theta_and_kappa_in_roi(obj,tid)
            % [R,THETA,KAPPA] = arc_length_theta_and_kappa_in_roi(obj,tid,npoints)
            %
            %   The whisker is parameterized as c(q) = (x(q),y(q)), where q 
            %   is in [0,1]. However, here we deal with a second representation of the
            %   whisker, where polynomials were fitted over a constant region of arc-length,
            %   [q0,q1], q0,q1 both within [0,1]. 
            %
            %   For this function to work properly, object properties 'faceSideInImage'
            %   and 'imagePixelDimsXY' must be correctly set.
            %
            % INPUTS:
            %
            %   tid: Whisker trajectory ID.
            %
            %   varargin{1}: Optional, integer giving number of points (values of q) to 
            %        use in reconstructing each whisker. Default is 100 points.  
            %    
            %
            % RETURNS:
            %
            %   R:  A cell array where each element is the arc length, computed moving outward from
            %       whisker follicle along the whisker for a single frame, but only those values
            %       falling within the ROI. Units of pixels.
            %
            %   THETA: A cell array where each element theta is the angle of the line tangent to the
            %           whisker (i.e., to c(q)) at each value of q in the ROI. In
            %           degrees.
            %
            %   KAPPA: A cell array where each element kappa is the signed curvature at each point
            %           on the whisker within the ROI. Units of 1/pixels. Abs(kappa(q)) is 1/X where X is
            %           the radius in pixels of the osculating circle at c(q). Uses the secondary polynomials
            %           fitted within the ROI.
            %
            %   Optionally also:
            %
            %   X,Y: Cell arrays containing the x and y image (pixel) coordinates corresponding to the
            %        values in R, THETA, and KAPPA.
            %
            %
            %
            %
            if nargin < 3
                npoints = 100;
            else
                npoints = varargin{1};
                if isempty(npoints)
                    npoints = 100;
                end
            end
            
            ind = find(obj.trajectoryIDs == tid);
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            
            nframes = size(obj.polyFitsROI{ind}{1},1);
            
            if isempty(obj.polyFitsROI)
                error('obj.polyFitsROI is empty.')
            end
            
            R = cell(1,nframes);
            THETA = cell(1,nframes);
            KAPPA = cell(1,nframes);
            
            if nargout>3
                X = cell(1,nframes);
                Y = cell(1,nframes);
            end
            
            fittedX = obj.polyFitsROI{ind}{1};
            fittedY = obj.polyFitsROI{ind}{2};
            fittedQ = obj.polyFitsROI{ind}{3};
            
            for k=1:nframes
                
                px = fittedX(k,:);
                py = fittedY(k,:);
                pq = fittedQ(k,:);
                
                q = linspace(pq(1),pq(2),npoints);
                
                pxDot = polyder(px);
                pxDoubleDot = polyder(pxDot);
                
                pyDot = polyder(py);
                pyDoubleDot = polyder(pyDot);
                
                xDot = polyval(pxDot,q);
                xDoubleDot = polyval(pxDoubleDot,q);
                
                yDot = polyval(pyDot,q);
                yDoubleDot = polyval(pyDoubleDot,q);
                
                dq = [0 diff(q)];
                
                % Arc length as a function of q, after integration below:
                R{k} = cumsum(sqrt(xDot.^2 + yDot.^2) .* dq); % arc length segments, in pixels, times dq.
                
                
                R{k} = R{k} + pq(3); % Add the whole-whisker arc-length of the first point in the ROI to make this quantity the arc-length
                                     % measured over the whole fitted whisker, not just arc-length over the ROI.
                                     % Note that pq(3) already accounts for mask, so do not need to do so in this method.
                

                % Angle (in degrees) as a function of q:
                % Protraction means theta is increasing.
                % Theta is 0 when perpendicular to the midline of the mouse.
                if strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'rightward')
                    THETA{k} = atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'top') && strcmp(obj.protractionDirection,'leftward')
                    THETA{k} = -atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'downward')
                    THETA{k} = atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'left') && strcmp(obj.protractionDirection,'upward')
                    THETA{k} = -atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'upward')
                    THETA{k} = atand(yDot ./ xDot); 
                elseif strcmp(obj.faceSideInImage,'right') && strcmp(obj.protractionDirection,'downward')
                    THETA{k} = -atand(yDot ./ xDot);
                elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'rightward')
                    THETA{k} = -atand(xDot ./ yDot);
                elseif strcmp(obj.faceSideInImage,'bottom') && strcmp(obj.protractionDirection,'leftward')
                    THETA{k} = atand(xDot ./ yDot);
                else
                    error('Invalid value of property ''faceSideInImage'' or ''protractionDirection''')
                end
                
                % Signed curvature as a function of q:
                KAPPA{k} = (xDot.*yDoubleDot - yDot.*xDoubleDot) ./ ((xDot.^2 + yDot.^2).^(3/2)); % SIGNED CURVATURE, in 1/pixels.
                %                 KAPPA{k} = abs(xDot.*yDoubleDot - yDot.*xDoubleDot) ./ ((xDot.^2 + yDot.^2).^(3/2)); % CURVATURE, in 1/pixels.
                
                if nargout>3
                    X{k} = polyval(px,q);
                    Y{k} = polyval(py,q);
                    varargout{1} = Y;
                    varargout{2} = X;
                end
            end
            
            % Do not need to apply any mask, because pq(3) above already accounts for mask.

        end
        
        function t = get_time(obj,tid)
            %
            %   t = get_time(obj,tid)
            %
            %   INPUTS:
            %       tid:  Trajectory ID (as an integer) or whisker name (as a string).
            %
            %   OUTPUTS:
            %       t: time in seconds for each sample in this WhiskerSignalTrial
            %       for given trajectory ID or whisker name.
            %
            if isnumeric(tid) % Trajectory ID specified.
                ind = find(obj.trajectoryIDs == tid);
            elseif ischar(tid) % Whisker name specified.
                ind = strmatch(tid,obj.whiskerNames,'exact');
            else
                error('Invalid type for argument ''tid''.')
            end
            
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            t = obj.time{ind};
        end
        
        function [rNearest,thetaNearest,kappaNearest,yNearest,xNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid,proximity_threshold)
            %
            % USAGE:
            %   [rNearest,thetaNearest,kappaNearest,yNearest,xNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid)
            %   [rNearest,thetaNearest,kappaNearest,yNearest,xNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid,proximity_threshold)
            %
            %
            %   INPUTS:
            %       tid:  Trajectory ID (as an integer) or whisker name (as a string).
            %       proximity_threshold:  Optional argument giving distance from nearest point on whisker
            %               to bar center, in units of bar radius, beyond which
            %               the whisker will be extrapolated along the last theta in
            %               order to determine distance between whisker and bar.
            %
            %   OUTPUTS:
            %       rNearest: Arc-length (radial) distance along whisker to point nearest
            %                 center of the bar. Units of pixels.
            %       thetaNearest: Theta at rNearest.
            %       kappaNearest: Kappa at rNearest.
            %       YNearest: Image-coordinate Y value at rNearest. This estimates point of contact. In pixels.
            %       XNearest: Image-coordinate X value at rNearest. This estimates point of contact. In pixels.
            %       dist: Distance from bar center to nearest point on whisker. Units of pixels.
            %       t: The corresponding times of each observation.
            %
            if isnumeric(tid) % Trajectory ID specified.
                ind = find(obj.trajectoryIDs == tid);
            elseif ischar(tid) % Whisker name specified.
                ind = strmatch(tid,obj.whiskerNames,'exact');
            else
                error('Invalid type for argument ''tid''.')
            end
            
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            
            if nargin < 3
                proximity_threshold = -1;
            end
            
            t = obj.time{ind};
            f = t / obj.framePeriodInSec;
            nframes = length(f);
            
            % Add any offset to the tracked bar position:
            if isempty(obj.barPosOffset);
                bp = obj.barPosClean;
            else
                bp = obj.barPosClean;
                if size(obj.barPosOffset,1)==1
                    bp = bp + repmat([0 obj.barPosOffset],size(bp,1),1);
                elseif size(obj.barPosOffset,1)==size(bp,1) && size(obj.barPosOffset,2)==2
                    bp = bp + obj.barPosOffset;
                else
                    error('Size of obj.barPosOffset is not valid; must be either 1 x 2 or nframes x 2.')
                end
            end
            
            bar_f = bp(:,1);
            bar_x = bp(:,2);
            bar_y = bp(:,3);
            
            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
            
            rNearest = zeros(1,nframes);
            thetaNearest = zeros(1,nframes);
            kappaNearest = zeros(1,nframes);
            dist = zeros(1,nframes);
            xNearest = zeros(1,nframes);
            yNearest = zeros(1,nframes);
            
            q = linspace(0,1); % This must be same as that used in obj.arc_length_theta_and_kappa().
            
            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};
            
            for k=1:nframes
                %                 disp(['Computing nearest-point values for frame=' int2str(k)])
                px = fittedX(k,:);
                py = fittedY(k,:);
                
                x = polyval(px,q);
                y = polyval(py,q);
                
%                 ind = bar_f == f(k);
                ind = abs(bar_f-f(k)) < 1e-12;
                
                if ~any(ind) || any(isnan(x)) || any(isnan(y))
                    rNearest(k) = NaN;
                    thetaNearest(k) = NaN;
                    kappaNearest(k) = NaN;
                    xNearest(k) = NaN;
                    yNearest(k) = NaN;
                    dist(k) = NaN;
                    continue
                end
                bx = bar_x(ind); % center of bar REPLACE_WITH_DASH_DASH offset if appropriate
                by = bar_y(ind);
                
                % Find closest point iteratively:
                npoints = length(x);
                d = zeros(npoints,1);
                for j=1:npoints
                    d(j) = sqrt((x(j)-bx)^2 + (y(j)-by)^2);
                end
                ind = find(d==min(d));
                ind = ind(1); % in case there are points of equal distance, take first; Later this should be first along arc-length of whisker*****
                
                if proximity_threshold < 0
                    dist(k) = d(ind) - obj.barRadius;
                elseif d(ind) < obj.barRadius*proximity_threshold
                    thetaW = THETA{k}(ind); % Angle of whisker at last point on whisker.
                    
                    if strcmp(obj.faceSideInImage,'top')
                        a = [tand(thetaW) 1]; % Vector extending from last point on whisker along angle of whisker.
                    elseif strcmp(obj.faceSideInImage,'bottom')  % DHO, 12oct11: Don't have test data for these conditions, remains untested
                        a = [tand(thetaW) -1]; % Vector extending from last point on whisker along angle of whisker.
                    elseif strcmp(obj.faceSideInImage,'left')
                        a = [1 tand(thetaW)]; % Vector extending from last point on whisker along angle of whisker.
                    else strcmp(obj.faceSideInImage,'right') % DHO, 12oct11: Don't have test data for these conditions, remains untested
                        a = [-1 tand(thetaW)]; % Vector extending from last point on whisker along angle of whisker.
                    end
                    
                    b = [bx-x(ind) by-y(ind)]; % Vector from last point on whisker to pole center.
                    a_norm = norm(a);
                    b_norm = norm(b);
                    thetaWP = abs(acosd(dot(a,b)/(a_norm*b_norm))); % Angle between whisker and pole. Don't care about sign, so take absolute value.
                    
                    dist(k) = b_norm*sind(thetaWP);
                    dist(k) = dist(k) - obj.barRadius;
                else
                    dist(k) = d(ind) - obj.barRadius;
                end
                
                
                rNearest(k) = R{k}(ind);
                thetaNearest(k) = THETA{k}(ind);
                kappaNearest(k) = KAPPA{k}(ind);
                xNearest(k) = x(ind);
                yNearest(k) = y(ind);
            end
        end
        
        function [theta0,kappa0,t] = get_theta_kappa_at_base(obj,tid)
            %
            %   [theta0,kappa0,t] = get_theta_kappa_at_base(obj,tid)
            %
            %   INPUTS:
            %       tid:  Trajectory ID (as an integer) or whisker name (as a string).
            %
            %   OUTPUTS:
            %
            %       theta0: Theta at radial distance 0. Radial distance 0 is determined
            %                     in part by the mask, if present. In degrees.
            %
            %       kappa0: kappa at radial distance 0. Radial distance 0 is determined
            %                     in part by the mask, if present. Units of 1/pixels.
            %
            %       t: The corresponding times of each observation.
            %
            if isnumeric(tid) % Trajectory ID specified.
                ind = find(obj.trajectoryIDs == tid);
            elseif ischar(tid) % Whisker name specified.
                ind = strmatch(tid,obj.whiskerNames,'exact');
            else
                error('Invalid type for argument ''tid''.')
            end
            
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            t = obj.time{ind};
            
            if all(isnan(t))
                disp(['Nothing tracked for tid ' int2str(tid) '; setting theta0,kappa0,t to NaN.'])
                theta0 = NaN;
                kappa0 = NaN;
                t = NaN;
                return
            end
            
            
            f = t / obj.framePeriodInSec;
            nframes = length(f);
            
            [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
            
            theta0 = zeros(1,nframes);
            kappa0 = zeros(1,nframes);
            
            for k=1:nframes
                r = R{k};
                rval = min(r(r >= 0)); % Take the minimum value >= 0.
                if isempty(rval)
                    theta0(k) = NaN;
                    kappa0(k) = NaN;
                else
                    ind = find(r==rval,1,'first');
                    theta0(k) = THETA{k}(ind);
                    kappa0(k) = KAPPA{k}(ind);
                end
            end
        end
        
        function [thetap,kappap,y,x,t] = get_theta_kappa_at_point(obj,tid,r_in_mm)
            %
            %   [thetap,kappap,y,x,t] = get_theta_kappa_at_point(obj,tid,r_in_mm)
            %
            %   INPUTS:
            %       tid:  Trajectory ID (as an integer) or whisker name (as a string).
            %
            %       r_in_mm: Distance along whisker at which to measure theta and kappa.
            %                Note that this calculation does not extrapolate back
            %                to the follicle. Alternatively, this argument can be given
            %                as the string 'max', in which case theta, kappa, y, x are
            %                given for the furthest arc-length distance along the whisker.
            %
            %
            %
            %   OUTPUTS:
            %
            %       thetap: Theta at radial distance specified by r_in_mm.
            %                     Radial distance is measured outward from the
            %                     intersection of the whisker and the mask, if present.
            %                     In degrees.
            %
            %       kappap: Kappa at radial distance specified by r_in_mm.
            %               Radial distance is determined outward from the intersection
            %               of the whisker and the mask, if present. Units of 1/pixels.
            %
            %       x,y: The image (pixel) coordinates of the point at r_in_mm.
            %
            %       t: The corresponding times of each observation.
            %
            if isnumeric(tid) % Trajectory ID specified.
                ind = find(obj.trajectoryIDs == tid);
            elseif ischar(tid) % Whisker name specified.
                ind = strmatch(tid,obj.whiskerNames,'exact');
            else
                error('Invalid type for argument ''tid''.')
            end
            
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            t = obj.time{ind};
            f = t / obj.framePeriodInSec;
            nframes = length(f);
            
            [R,THETA,KAPPA,Y,X] = obj.arc_length_theta_and_kappa(tid);
            
            thetap = zeros(1,nframes);
            kappap = zeros(1,nframes);
            x = zeros(1,nframes);
            y = zeros(1,nframes);
            
            if ischar(r_in_mm)
                if ~strcmp(r_in_mm,'max')
                    error('Invalid value for argument ''r_in_mm''')
                end
                for k=1:nframes
                    if isempty(R{k})
                        thetap(k) = NaN;
                        kappap(k) = NaN;
                        y(k) = NaN;
                        x(k) = NaN;
                    else
                        thetap(k) = THETA{k}(end);
                        kappap(k) = KAPPA{k}(end);
                        y(k) = Y{k}(end);
                        x(k) = X{k}(end);
                    end
                end
            else
                for k=1:nframes
                    r = R{k} / obj.pxPerMm;
                    rval = min(r(r >= r_in_mm)); % Take the minimum value >= r_in_mm.
                    if isempty(rval)
                        thetap(k) = NaN;
                        kappap(k) = NaN;
                        y(k) = NaN;
                        x(k) = NaN;
                    else
                        ind = find(r==rval,1,'first');
                        thetap(k) = THETA{k}(ind);
                        kappap(k) = KAPPA{k}(ind);
                        y(k) = Y{k}(ind);
                        x(k) = X{k}(ind);
                    end
                end
            end
            
            
        end
        
        function [thetap,kappap,y,x,t] = get_theta_kappa_at_roi_point(obj,tid,r_in_mm)
            %
            %   [thetap,kappap,y,x,t] = get_theta_kappa_at_roi_point(obj,tid,r_in_mm)
            %
            %   INPUTS:
            %       tid:  Trajectory ID (as an integer) or whisker name (as a string).
            %
            %       r_in_mm: Distance along whisker at which to measure theta and kappa.
            %                Note that this calculation does not extrapolate back
            %                to the follicle. Also, r_in_mm **MUST FALL WITHIN THE ROI**
            %                or else a NaN is returned.
            %
            %
            %   OUTPUTS:
            %
            %       thetap: Theta at radial distance specified by r_in_mm.
            %                     Radial distance is measured outward from the
            %                     intersection of the whisker and the mask, if present.
            %                     In degrees.
            %
            %       kappap: Kappa at radial distance specified by r_in_mm.
            %               Radial distance is determined outward from the intersection
            %               of the whisker and the mask, if present. Units of 1/pixels.
            %
            %       x,y: The image (pixel) coordinates of the point at r_in_mm.
            %
            %       t: The corresponding times of each observation.
            %
            if isnumeric(tid) % Trajectory ID specified.
                ind = find(obj.trajectoryIDs == tid);
            elseif ischar(tid) % Whisker name specified.
                ind = strmatch(tid,obj.whiskerNames,'exact');
            else
                error('Invalid type for argument ''tid''.')
            end
            
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            t = obj.time{ind};
            f = t / obj.framePeriodInSec;
            nframes = length(f);
            
            [R,THETA,KAPPA,Y,X] = obj.arc_length_theta_and_kappa_in_roi(tid); 
            
            thetap = zeros(1,nframes);
            kappap = zeros(1,nframes);
            x = zeros(1,nframes);
            y = zeros(1,nframes);
            
            for k=1:nframes
                r = R{k} / obj.pxPerMm;
                rval = min(r(r >= r_in_mm)); % Take the minimum value >= r_in_mm.
                if isempty(rval)
                    disp('r_in_mm not found within fitted whisker ROI; setting to NaN for this frame.')
                    thetap(k) = NaN;
                    kappap(k) = NaN;
                    y(k) = NaN;
                    x(k) = NaN;
                else
                    ind = find(r==rval,1,'first');
                    thetap(k) = THETA{k}(ind);
                    kappap(k) = KAPPA{k}(ind);
                    y(k) = Y{k}(ind);
                    x(k) = X{k}(ind);
                end
            end
        end
        
        function [M0,Faxial,t,varargout] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
                whisker_length,youngs_modulus,baseline_time_or_kappa_value, varargin)
            %
            %   DHO 6/18/10 NOTE: This should be rewritten using inputParser. 
            %
            % USAGE:
            %
            %    function [M0,Faxial,t] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,varargout] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,deltaKappa] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,deltaKappa,Fnorm] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact,distanceToPoleCenter] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact,distanceToPoleCenter, meanKappa] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact,distanceToPoleCenter, meanKappa, Flateral] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value)
            %
            %    function [M0,Faxial,t,deltaKappa,Fnorm,thetaAtBase,thetaAtContact,distanceToPoleCenter, meanKappa, Flateral] = calc_M0_Faxial(obj,tid,r_point,whisker_radius_at_base,...
            %      whisker_length,youngs_modulus,baseline_time_or_kappa_value,proximity_threshold)            
            %
            %
            % INPUTS:
            %
            % 	tid:  trajectory ID or string specifying the whisker the use.
            % 	r_point: radial distance along whisker at which to measure kappa. In mm.
            % 	whisker_radius_at_base: Given in microns.
            % 	whisker_length: Given in mm.
            % 	youngs_modulus: In Pa.
            % 	baseline_time_or_kappa_value: Either (1) a 1x2 vector giving starting and stopping times (inclusive) for measuring baseline whisker curvature, in sec; 
            %                                 or (2) a scaler giving a baseline kappa value (measured by the user separately) to directly subtract from kappa
            %                                 timeseries, in 1/mm.
            %
            %   Optionally,
            %       
            %   proximity_threshold:  Optional argument giving distance from nearest point on whisker
            %                         to bar center, in units of bar radius, beyond which
            %                         the whisker will be extrapolated along the last theta in
            %                         order to determine distance between whisker and bar.             
            %
            % OUTPUTS:
            %
            % 	M0:  Moment at the follicle. In Newton-meters.
            % 	Faxial: Axial force into follice. In Newtons.
            % 	t: The time of each M0, Faxial observation. In sec.
            %
            % 	Optionally,
            %
            % 	deltaKappa = Change from baseline curvature, at point specified by r_point. In 1/mm.
            % 	Fnorm - The force on the whisker normal to the contacted object. In Newtons.
            %   thetaAtBase - The whisker angle nearest the follicle. In degrees.
            %   thetaAtContact - The whisker angle nearest the point of contact. I.e., nearest the center of the pole. In degrees.
            %   distanceToPoleCenter - The closest distance between the whisker and the center of the pole. In mm.
            %   meanKappa - The mean of kappa over the entire secondary polynomial fitted ROI. In 1/mm.
            %   Flateral - Lateral force, orthogonal to Faxial; pushes the whisker against the posterior side of the follicle. In Newtons.
            %
            % REQUIRES:
            % 	-Follicle coordinates are already computed.
            % 	-Property pxPerMm is set correctly for the current videographic conditions.
            % 	-Property faceSideInImage is set correctly.
            % 	-Property barPos is set correctly.
            %
            % Assumptions:
            % 	-Whisker is conical.
            %   -Young's modulus is same everywhere on whisker.
            %   -Whisker cross-section is circular.
            %
            %
            if nargin > 7
                proximity_threshold = varargin{1};
            else
                proximity_threshold = -1; % -1 means unused
            end
            
            if isnumeric(tid) % Trajectory ID specified.
                ind = find(obj.trajectoryIDs == tid);
            elseif ischar(tid) % Whisker name specified.
                ind = strmatch(tid,obj.whiskerNames,'exact');
            else
                error('Invalid type for argument ''tid''.')
            end
            
            if isempty(ind)
                error('Could not find specified trajectory ID.')
            end
            
            if isempty(obj.follicleCoordsX) || isempty(obj.follicleCoordsX)
                error(['obj.follicleCoordsX or obj.follicleCoordsY is empty. ' ...
                    'Must run obj.recompute_cached_follicle_coords before this method.'])
            end
            
            if isempty(obj.barPos)
                error('obj.barPos is empty. Bar position is required to define point of contact.')
            end
            
            r_point = r_point * 1e-3; % Argument given in mm; convert to meters.
            whisker_radius_at_base = whisker_radius_at_base * 1e-6; % Argument given in micrometers; convert to meters.
            whisker_length = whisker_length * 1e-3;  % Argument given in mm; convert to meters.
            
            pixelsPerMeter = 1e3 * obj.pxPerMm;
            
            % DHO 11/5/10: Need to access follicleExtrapDistanceInPix and then add that (mm/pixel converted) value
            % to r_point in equation for II. Otherwise the base of the cone (whisker) starts not at the follicle but
            % at the first tracked point or at the intersection of the whisker and the mask, if a mask is defined.
            II = pi/4*(whisker_radius_at_base*(1-(r_point+obj.follicleExtrapDistInPix./pixelsPerMeter)/whisker_length))^4; % In Meters^4. Eqn A2,3 from Birdwell et al.
            
%             II = pi/4*(whisker_radius_at_base*(1-r_point/whisker_length))^4; % In Meters^4. Eqn A2,3 from Birdwell et al.
            EI = youngs_modulus*II; % Meter^4-pascals. Bending stiffness at point r_point.
            
            x0 = obj.follicleCoordsX{ind};
            y0 = obj.follicleCoordsY{ind};
            
            if isempty(x0) || isempty(y0)
              disp(['No follicle coordinates computed for tid ' int2str(tid) ', cannot compute forces, setting to NaN.'])
              t = obj.time{ind};
              x0 = nan(size(t));
              y0 = nan(size(t));
            end

            
            % Could speed up by combining next few lines, since several call arc_length_theta_and_kappa().
            % From one function call, need to get:
            %   t, theta0, kappaPoint, yPoint, xPoint, meanKappa (from ROIKAPPA), thetaContact, yContact, xContact, distanceToPoleCenter 
            
            FC = obj.get_force_calc_vals(tid, r_point*1e3, proximity_threshold); % Give r_point argument in mm.
            
            % get_force_calc_vals() combines:
            %            [theta0,tmp,t] = obj.get_theta_kappa_at_base(tid);
            %            [tmp,kappaPoint,yPoint,xPoint,t] = obj.get_theta_kappa_at_roi_point(tid,r_point*1e3)
            %            [tmp1,thetaContact,tmp2,yContact,xContact,distanceToPoleCenter,t] = obj.get_r_theta_kappa_nearest_bar(tid);
            %
            % FC is structure with fields: t (sec), theta0 (degrees), kappaPoint (1/pixels), yPoint (pixels), xPoint (pixels),
            % meanKappa (in ROI; 1/pixels), thetaContact (degrees), yContact (pixels), xContact (pixels), distanceToPoleCenter (pixels).
                        % Construct output structure:
                        
            t = FC.t; % In sec
            theta0 = FC.theta0; % In degrees
            kappaPoint = FC.kappaPoint; % In 1/pixels
            yPoint = FC.yPoint; % In pixels
            xPoint = FC.xPoint; % In pixels
            meanKappa = FC.meanKappa; % In 1/pixels.
            thetaContact = FC.thetaContact; % In 1/pixels
            yContact = FC.yContact; % In pixels
            xContact = FC.xContact; % In pixels
            distanceToPoleCenter = FC.distanceToPoleCenter; % In pixels
            
%            [theta0, t] = obj.get_fitted_line_angle_in_roi(obj,tid,[0 32]) 
            [theta0,tmp,t] = obj.get_theta_kappa_at_point(tid,0.5); %  
            
%             [tmp,kappaPoint,yPoint,xPoint,t] = obj.get_theta_kappa_at_roi_point(tid,r_point*1e3); % Give second argument in mm. kappaPoint in 1/pixels.
            
            if numel(baseline_time_or_kappa_value)==2
                disp(['Using kappa averaged over times ' num2str(baseline_time_or_kappa_value(1)) ' to ' num2str(baseline_time_or_kappa_value(2)) ...
                    ' (inclusive) for baseline kappa for trajectory ID ' int2str(tid) '.'])
                baselineKappa = pixelsPerMeter * nanmean(kappaPoint(t >= baseline_time_or_kappa_value(1) & t <= baseline_time_or_kappa_value(2))); % Now in 1/m.
            elseif numel(baseline_time_or_kappa_value)==1
                disp(['Using user-specified kappa value of ' num2str(baseline_time_or_kappa_value) ' 1/mm for baseline kappa for trajectory ID ' int2str(tid) '.'])
                baselineKappa = baseline_time_or_kappa_value * 1e3; % baseline_time_or_kappa_value given in 1/mm; convert to 1/m.
            else 
                error('Argument ''baseline_time_or_kappa_value'' has wrong number of elements.')
            end
            
            kappaPoint = pixelsPerMeter * kappaPoint - baselineKappa; % In 1/m.
            
%             [tmp,tmp1,ROIKAPPA] = obj.arc_length_theta_and_kappa_in_roi(tid);
%             meanKappa = cellfun(@mean, ROIKAPPA); % In 1/pixels.
            
            meanKappa = pixelsPerMeter * meanKappa - baselineKappa;
            
%             [tmp1,thetaContact,tmp2,yContact,xContact,distanceToPoleCenter,t] = obj.get_r_theta_kappa_nearest_bar(tid);
            
            theta0 = theta0*(2*pi/360); % Convert all angles to radians.
            thetaContact = thetaContact*(2*pi/360);
            
            rPointNorm = sqrt((xContact-xPoint).^2 + (yContact-yPoint).^2) / pixelsPerMeter; % in meters.
            r0Norm = sqrt((xContact-x0).^2 + (yContact-y0).^2) / pixelsPerMeter; % in meters.
            
            %**** CHECK: NEED TO ACCOUNT FROM PROTRACTION DIRECTION IN FOLLOWING? *******
            
            % Get angle of vector from r_point to contact point:
            dx = (xContact-xPoint); dy = (yContact-yPoint);
            if strcmp(obj.faceSideInImage,'top') || strcmp(obj.faceSideInImage,'bottom')
                thetaPoint2Cont = atan(dx./dy);
            else
                thetaPoint2Cont = atan(dy./dx);
            end
            
            % Get angle of vector from follicle to contact point:
            dx = (xContact-x0); dy = (yContact-y0);
            if strcmp(obj.faceSideInImage,'top') || strcmp(obj.faceSideInImage,'bottom')
                thetaFoll2Cont = atan(dx./dy);
            else
                thetaFoll2Cont = atan(dy./dx);
            end
            
            Fnorm = (kappaPoint*EI) ./ (rPointNorm .* sin(pi/2 + thetaPoint2Cont - thetaContact)); % in Newtons
            Faxial = Fnorm.*sin(theta0 - thetaContact); % in Newtons.
            Flateral = Fnorm.*cos(theta0 - thetaContact); % in Newtons.
            M0 = r0Norm.*Fnorm.*sin(pi/2 + thetaFoll2Cont - thetaContact); % in Newton-meters
            
            if nargout > 3
                varargout{1} = kappaPoint / 1e3; % kappaPoint in 1/m; return in 1/mm.
            end
            if nargout > 4
                varargout{2} = Fnorm;
            end
            if nargout > 5
                varargout{3} = theta0 / (2*pi/360); % Whisker angle nearest the follicle. Currently in radians; return in degrees.
            end
            if nargout > 6
                varargout{4} = thetaContact / (2*pi/360); % Whisker angle at point nearest center of pole. Currently in radians; return in degrees.
            end
            if nargout > 7
                varargout{5} = distanceToPoleCenter / obj.pxPerMm; % distanceToPoleCenter in pixels; return in mm.
            end
            if nargout > 8
               varargout{6} = meanKappa / 1e3; % meanKappa in 1/m; return in 1/mm.
            end
            if nargout > 9
               varargout{7} = Flateral; % In Newtons.
            end
        end
        
        function FC = get_force_calc_vals(obj, tid, r_in_mm, varargin)
            %
            % INPUTS:
            %
            % 	tid:  trajectory ID or string specifying the whisker the use.
            % 	r_in_mm: radial distance along whisker at which to measure kappa. In mm.
            %   
            %   Optionally, varargin{1} can be 'proximity_threshold' argument, giving distance from nearest point on whisker
            %    to bar center, in units of bar radius, beyond which
            %    the whisker will be extrapolated along the last theta in
            %    order to determine distance between whisker and bar. 
            % 
            %
            % OUTPUTS:
            %
            % FC: A structure with fields: t (sec), theta0 (degrees), kappaPoint (1/pixels), yPoint (pixels), xPoint (pixels),
            % meanKappa (in ROI; 1/pixels), thetaContact (degrees), yContact (pixels), xContact (pixels), distanceToPoleCenter (pixels).
            %
            % Explanation of fields:
            %       theta0: Theta at radial distance 0. Radial distance 0 is determined
            %                     in part by the mask, if present. In degrees.
            %
            % This method combines features of the following methods, but is more efficient
            % than calling all of the following methods separately:
            %            [theta0,tmp,t] = obj.get_theta_kappa_at_base(tid);
            %            [tmp,kappaPoint,yPoint,xPoint,t] = obj.get_theta_kappa_at_roi_point(tid,r_point*1e3)
            %            [tmp1,thetaContact,tmp2,yContact,xContact,distanceToPoleCenter,t] = obj.get_r_theta_kappa_nearest_bar(tid);
            %
            %
            
            
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            
            %   [theta0,kappa0,t] = get_theta_kappa_at_base(obj,tid)
            %
            %   INPUTS:
            %       tid:  Trajectory ID (as an integer) or whisker name (as a string).
            %
            %   OUTPUTS:
            %
            %       theta0: Theta at radial distance 0. Radial distance 0 is determined
            %                     in part by the mask, if present. In degrees.
            %
            %       t: The corresponding times of each observation.
            %

            if isnumeric(tid) % Trajectory ID specified.
                ind_tid = find(obj.trajectoryIDs == tid);
            elseif ischar(tid) % Whisker name specified.
                ind_tid = strmatch(tid,obj.whiskerNames,'exact');
            else
                error('Invalid type for argument ''tid''.')
            end
            
            if isempty(ind_tid)
                error('Could not find specified trajectory ID.')
            end
            t = obj.time{ind_tid};
            
            if all(isnan(t)) %*** MODIFY?
                disp(['Nothing tracked for tid ' int2str(tid) '; setting theta0,kappa0,t to NaN.'])
                theta0 = NaN;
                t = NaN;
                return
            end
            
            f = t / obj.framePeriodInSec;
            nframes = length(f);
            
            [R,THETA] = obj.arc_length_and_theta(tid); 
            
            theta0 = zeros(1,nframes);
            
            for k=1:nframes
                r = R{k};
                rval = min(r(r >= 0)); % Take the minimum value >= 0.
                if isempty(rval)
                    theta0(k) = NaN;
                else
                    ind = find(r==rval,1,'first');
                    theta0(k) = THETA{k}(ind);
                end
            end
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            %   [thetap,kappap,y,x,t] = get_theta_kappa_at_roi_point(obj,tid,r_in_mm)
            %
            %   INPUTS:
            %       tid:  Trajectory ID (as an integer) or whisker name (as a string).
            %
            %       r_in_mm: Distance along whisker at which to measure theta and kappa.
            %                Note that this calculation does not extrapolate back
            %                to the follicle. Also, r_in_mm **MUST FALL WITHIN THE ROI**
            %                or else a NaN is returned.
            %
            %
            %   OUTPUTS:
            %
            %
            %       kappaPoint: Kappa at radial distance specified by r_in_mm.
            %               Radial distance is determined outward from the intersection
            %               of the whisker and the mask, if present. Units of 1/pixels.
            %
            %       xPoint,yPoint: The image (pixel) coordinates of the point at r_in_mm.
            %
            %       t: The corresponding times of each observation.
            %
            
            [R_ROI,THETA_ROI,KAPPA_ROI,Y,X] = obj.arc_length_theta_and_kappa_in_roi(tid);
            
            kappaPoint = zeros(1,nframes);
            xPoint = zeros(1,nframes);
            yPoint = zeros(1,nframes);
            
            for k=1:nframes
                r = R_ROI{k} / obj.pxPerMm;
                rval = min(r(r >= r_in_mm)); % Take the minimum value >= r_in_mm.
                if isempty(rval)
                    disp('r_in_mm not found within fitted whisker ROI; setting to NaN for this frame.')
                    kappaPoint(k) = NaN;
                    yPoint(k) = NaN;
                    xPoint(k) = NaN;
                else
                    ind = find(r==rval,1,'first');
                    kappaPoint(k) = KAPPA_ROI{k}(ind);
                    yPoint(k) = Y{k}(ind);
                    xPoint(k) = X{k}(ind);
                end
            end
            %REPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASHREPLACE_WITH_DASH_DASH
            %   [rNearest,thetaNearest,kappaNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid)
            %   [rNearest,thetaNearest,kappaNearest,dist,t] = get_r_theta_kappa_nearest_bar(obj,tid,proximity_threshold)
            %
            %
            %   INPUTS:
            %       tid:  Trajectory ID (as an integer) or whisker name (as a string).
            %       proximity_threshold:  Optional argument giving distance from nearest point on whisker
            %               to bar center, in units of bar radius, beyond which
            %               the whisker will be extrapolated along the last theta in
            %               order to determine distance between whisker and bar.
            %
            %   OUTPUTS:
            %       rNearest: Arc-length (radial) distance along whisker to point nearest
            %                 center of the bar. Units of pixels.
            %       thetaNearest: Theta at rNearest.
            %       kappaNearest: Kappa at rNearest.
            %       YNearest: Image-coordinate Y value at rNearest. This estimates point of contact. In pixels.
            %       XNearest: Image-coordinate X value at rNearest. This estimates point of contact. In pixels.
            %       dist: Distance from bar center to nearest point on whisker. Units of pixels.
            %       t: The corresponding times of each observation.
            %
            
            if nargin < 4
                proximity_threshold = -1; 
            else
                proximity_threshold = varargin{1};
            end
            
            % Add any offset to the tracked bar position:
            if isempty(obj.barPosOffset);
                bp = obj.barPosClean;
            else
                bp = obj.barPosClean;
                if size(obj.barPosOffset,1)==1
                    bp = bp + repmat([0 obj.barPosOffset],size(bp,1),1);
                elseif size(obj.barPosOffset,1)==size(bp,1) && size(obj.barPosOffset,2)==2
                    bp = bp + obj.barPosOffset;
                else
                    error('Size of obj.barPosOffset is not valid; must be either 1 x 2 or nframes x 2.')
                end
            end
            
            bar_f = bp(:,1);
            bar_x = bp(:,2);
            bar_y = bp(:,3);
            
            %             [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
            
            thetaNearest = zeros(1,nframes);
            dist = zeros(1,nframes);
            xNearest = zeros(1,nframes);
            yNearest = zeros(1,nframes);
            
            q = linspace(0,1); % This must be same as that used in obj.arc_length_theta_and_kappa().
            
            fittedX = obj.polyFits{ind_tid}{1};
            fittedY = obj.polyFits{ind_tid}{2};
            
            for k=1:nframes
                %                 disp(['Computing nearest-point values for frame=' int2str(k)])
                px = fittedX(k,:);
                py = fittedY(k,:);
                
                x = polyval(px,q);
                y = polyval(py,q);
                
                %                 ind = bar_f == f(k);
                ind = abs(bar_f-f(k)) < 1e-12;
                
                if ~any(ind) || any(isnan(x)) || any(isnan(y))
                    thetaNearest(k) = NaN;
                    xNearest(k) = NaN;
                    yNearest(k) = NaN;
                    dist(k) = NaN;
                    continue
                end
                bx = bar_x(ind); % center of bar REPLACE_WITH_DASH_DASH offset if appropriate
                by = bar_y(ind);
                
                % Find closest point iteratively:
                npoints = length(x);
                d = zeros(npoints,1);
                for j=1:npoints
                    d(j) = sqrt((x(j)-bx)^2 + (y(j)-by)^2);
                end
                ind = find(d==min(d));
                ind = ind(1); % in case there are points of equal distance, take first; Later this should be first along arc-length of whisker*****
                
                if proximity_threshold < 0
                    dist(k) = d(ind) - obj.barRadius;
                elseif d(ind) < obj.barRadius*proximity_threshold
                    thetaW = THETA{k}(ind); % Angle of whisker at last point on whisker.
                    
                    if strcmp(obj.faceSideInImage,'top')
                        a = [tand(thetaW) 1]; % Vector extending from last point on whisker along angle of whisker.
                    elseif strcmp(obj.faceSideInImage,'bottom')  % DHO, 12oct11: Don't have test data for these conditions, remains untested
                        a = [tand(thetaW) -1]; % Vector extending from last point on whisker along angle of whisker.
                    elseif strcmp(obj.faceSideInImage,'left')
                        a = [1 tand(thetaW)]; % Vector extending from last point on whisker along angle of whisker.
                    else strcmp(obj.faceSideInImage,'right') % DHO, 12oct11: Don't have test data for these conditions, remains untested
                        a = [-1 tand(thetaW)]; % Vector extending from last point on whisker along angle of whisker.
                    end
                    
                    b = [bx-x(ind) by-y(ind)]; % Vector from last point on whisker to pole center.
                    a_norm = norm(a);
                    b_norm = norm(b);
                    thetaWP = abs(acosd(dot(a,b)/(a_norm*b_norm))); % Angle between whisker and pole. Don't care about sign, so take absolute value.
                    
                    dist(k) = b_norm*sind(thetaWP);
                    dist(k) = dist(k) - obj.barRadius;
                else
                    dist(k) = d(ind) - obj.barRadius;
                end
                
                thetaNearest(k) = THETA{k}(ind);
                xNearest(k) = x(ind);
                yNearest(k) = y(ind);
            end
            
            % Construct output structure:
            FC.t = t; % In sec
            FC.theta0 = theta0; % In degrees
            FC.kappaPoint = kappaPoint; % In 1/pixels
            FC.yPoint = yPoint; % In pixels
            FC.xPoint = xPoint; % In pixels
            FC.meanKappa = cellfun(@mean, KAPPA_ROI); % In 1/pixels.
            FC.thetaContact = thetaNearest; % In 1/pixels
            FC.yContact = yNearest; % In pixels
            FC.xContact = xNearest; % In pixels
            FC.distanceToPoleCenter = dist; % In pixels
            
        end
        
        
        function varargout = plot_fitted_whisker_time_projection(obj, tid, varargin)
            %
            %   varargout = plot_fitted_whisker_time_projection(obj, tid, varargin)
            %
            % USAGE:
            %       plot_fitted_whisker_time_projection(obj, tid, varargin)
            %       [X,Y] = plot_fitted_whisker_time_projection(obj, tid, varargin)
            %
            % INPUTS:
            %
            % tid: trajectory ID.  Only a single ID is allowed.
            %
            % varargin{1}: Plot color/symbol string.
            %
            % varargin{2}: Optional 2 x 1 vector giving starting and ending times (in seconds) to include in
            %               returned image, inclusive, starting with 0.
            %               Of format: [startTimeInSec endTimeInSec]. Can be empty ([]) to allow
            %               access to varargin{3}.
            %
            % varargin{3}: Cell array with two elements. First element is a 1x2 vector giving radial distance
            %              beginning and end points (inclusive) to draw in the color given in
            %              varargin{1}, in format [startRadialDistance stopRadialDistance]. Radial distance
            %              is whisker arc length moving outward from follicle and is in units of pixels.
            %              The second element of the cell array is the plot color/symbol string to use when
            %              plotting the radial segment of the whisker between startRadialDistance and
            %              stopRadialDistance.
            %
            % OUTPUTS:
            %
            % If no output argument is requested, only plotting happens.  If two output argument
            % is requested, two cell arrays of length nframes are returned, X, and Y, each element of which
            % contain the x and y data, respectively, that were plotted for a given frame.
            %
            %
            if numel(tid) > 1
                error('Only a single trajectory ID is alowed.')
            end
            
            if nargin > 2
                plotString = varargin{1};
            else
                plotString = 'k-';
            end
            
            t = obj.get_time(tid);
            
            if nargin > 3
                restrictTime = varargin{2};
                if isempty(restrictTime)
                    restrictTime = [min(t) max(t)];
                elseif restrictTime(2) <= restrictTime(1)
                    error('Invalid format for varargin{2}.')
                elseif max(restrictTime) > max(t)
                    disp('Warning: varargin{2} exceeds max time; setting to max.')
                    restrictTime(restrictTime==max(restrictTime)) = max(t);
                    if restrictTime(1)==restrictTime(2)
                        error('varargin{2}: Both times exceed max time.')
                    end
                elseif min(restrictTime < 0)
                    disp('varargin{2}: times start at 0.')
                end
            else
                restrictTime = [min(t) max(t)];
            end
            
            if nargin > 4
                if ~iscell(varargin{3})
                    error('Wrong format for varargin{3}.')
                end
                plotString2 = varargin{3}{2};
                rstart = varargin{3}{1}(1);
                rstop = varargin{3}{1}(2);
            end
            
            frameInds = find(t >= restrictTime(1) & t <= restrictTime(2));
            
            hold on; axis ij
            
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Could not find specified trajectory ID.')
            end
            
            if isempty(obj.polyFits)
                error('obj.polyFits is empty.')
            end
            
            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};
            
            nframes = length(frameInds);
            x = cell(1,nframes);
            y = cell(1,nframes);
            
            q = linspace(0,1);
            
            for k=1:nframes
                f = frameInds(k);
                
                px = fittedX(f,:);
                py = fittedY(f,:);
                x{k} = polyval(px,q);
                y{k} = polyval(py,q);
            end
            
            X = cell(1,nframes);
            Y = cell(1,nframes);
            
            if nargin > 4
                [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
                for k=1:nframes
                    xx = x{k};
                    yy = y{k};
                    f = frameInds(k);
                    radDist = R{f};
                    plot(xx,yy,plotString)
                    rind = radDist >= rstart & radDist <= rstop;
                    plot(xx(rind),yy(rind),plotString2)
                    X{k} = xx(rind);
                    Y{k} = yy(rind);
                end
            else
                for k=1:nframes
                    plot(x{k},y{k},plotString)
                    X{k} = x{k};
                    Y{k} = y{k};
                end
            end
            
            if nargout == 1 || nargout > 2
                error('Invalid number of output arguments.')
            elseif nargout == 2
                varargout{1} = X;
                varargout{2} = Y;
            end
            
        end
        
        function plot_fitted_whisker_ROI_time_projection(obj, tid, varargin)
            %
            %   plot_fitted_whisker_time_ROI_projection(obj, tid, varargin)
            %
            % Plots whisker, but only the part within the secondary polynomial
            % fitting ROI.
            %
            % tid: trajectory ID.  Only a single ID is allowed.
            %
            % varargin{1}: Plot color/symbol string.
            %
            % varargin{2}: Optional 2 x 1 vector giving starting and ending times (in seconds) to include in
            %               returned image, inclusive, starting with 0.
            %               Of format: [startTimeInSec endTimeInSec]. Can be empty ([]) to allow
            %               access to varargin{3}.
            %
            %
            %
            if numel(tid) > 1
                error('Only a single trajectory ID is alowed.')
            end
            
            if nargin > 2
                plotString = varargin{1};
            else
                plotString = 'k-';
            end
            
            t = obj.get_time(tid);
            
            if nargin > 3
                restrictTime = varargin{2};
                if isempty(restrictTime)
                    restrictTime = [min(t) max(t)];
                elseif restrictTime(2) <= restrictTime(1)
                    error('Invalid format for varargin{2}.')
                elseif max(restrictTime) > max(t)
                    disp('Warning: varargin{2} exceeds max time; setting to max.')
                    restrictTime(restrictTime==max(restrictTime)) = max(t);
                    if restrictTime(1)==restrictTime(2)
                        error('varargin{2}: Both times exceed max time.')
                    end
                elseif min(restrictTime < 0)
                    disp('varargin{2}: times start at 0.')
                end
            else
                restrictTime = [min(t) max(t)];
            end
            
            frameInds = find(t >= restrictTime(1) & t <= restrictTime(2));
            
            hold on; axis ij
            
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Could not find specified trajectory ID.')
            end
            
            if isempty(obj.polyFitsROI)
                error('obj.polyFitsROI is empty.')
            end
            
            fittedX = obj.polyFitsROI{ind}{1};
            fittedY = obj.polyFitsROI{ind}{2};
            fittedQ = obj.polyFitsROI{ind}{3};
            
            nframes = length(frameInds);
            x = cell(1,nframes);
            y = cell(1,nframes);
                       
            for k=1:nframes
                f = frameInds(k);
                
                px = fittedX(f,:);
                py = fittedY(f,:);
                pq = fittedQ(f,:);
                
                q = linspace(pq(1),pq(2));
                
                x{k} = polyval(px,q);
                y{k} = polyval(py,q);
                
                plot(x{k},y{k},plotString)
            end
        end
        
        function plot_fitted_whisker_movie(obj, tid, varargin)
            %
            %   plot_fitted_whisker_movie(obj, tid, varargin)
            %
            % tid: trajectory ID.  Only a single ID is allowed.
            %
            % varargin{1}: Plot color/symbol string.
            %
            % varargin{2}: Optional 2 x 1 vector giving starting and ending times (in seconds) to include in
            %               returned image, inclusive, starting with 0.
            %               Of format: [startTimeInSec endTimeInSec]. Can be empty ([]) to allow
            %               access to varargin{3}.
            %
            % varargin{3}: Cell array with two elements. First element is a 1x2 vector giving radial distance
            %              beginning and end points (inclusive) to draw in the color given in
            %              varargin{1}, in format [startRadialDistance stopRadialDistance]. Radial distance
            %              is whisker arc length moving outward from follicle and is in units of pixels.
            %              The second element of the cell array is the plot color/symbol string to use when
            %              plotting the radial segment of the whisker between startRadialDistance and
            %              stopRadialDistance.
            %
            %
            %
            if numel(tid) > 1
                error('Only a single trajectory ID is alowed.')
            end
            
            if nargin > 2
                plotString = varargin{1};
            else
                plotString = 'k-';
            end
            
            t = obj.get_time(tid);
            
            if nargin > 3
                restrictTime = varargin{2};
                if isempty(restrictTime)
                    restrictTime = [min(t) max(t)];
                elseif restrictTime(2) <= restrictTime(1)
                    error('Invalid format for varargin{2}.')
                elseif max(restrictTime) > max(t)
                    disp('Warning: varargin{2} exceeds max time; setting to max.')
                    restrictTime(restrictTime==max(restrictTime)) = max(t);
                    if restrictTime(1)==restrictTime(2)
                        error('varargin{2}: Both times exceed max time.')
                    end
                elseif min(restrictTime < 0)
                    disp('varargin{2}: times start at 0.')
                end
            else
                restrictTime = [min(t) max(t)];
            end
            
            if nargin > 4
                if ~iscell(varargin{3})
                    error('Wrong format for varargin{3}.')
                end
                plotString2 = varargin{3}{2};
                rstart = varargin{3}{1}(1);
                rstop = varargin{3}{1}(2);
            end
            
            frameInds = find(t >= restrictTime(1) & t <= restrictTime(2));
            
            hold on; axis ij
            
            ind = obj.trajectoryIDs==tid;
            if max(ind) < 1
                error('Could not find specified trajectory ID.')
            end
            
            if isempty(obj.polyFits)
                error('obj.polyFits is empty.')
            end
            
            fittedX = obj.polyFits{ind}{1};
            fittedY = obj.polyFits{ind}{2};
            
            nframes = length(frameInds);
            x = cell(1,nframes);
            y = cell(1,nframes);
            
            q = linspace(0,1);
            
            for k=1:nframes
                f = frameInds(k);
                px = fittedX(f,:);
                py = fittedY(f,:);
                x{k} = polyval(px,q);
                y{k} = polyval(py,q);
            end
            
            if nargin > 4
                [R,THETA,KAPPA] = obj.arc_length_theta_and_kappa(tid);
                for k=1:nframes
                    xx = x{k};
                    yy = y{k};
                    f = frameInds(k);
                    radDist = R{f};
                    plot(xx,yy,plotString)
                    rind = radDist >= rstart & radDist <= rstop;
                    plot(xx(rind),yy(rind),plotString2)
                    title(['t=' num2str(t(k)) ' s'])
                    pause(.1)
                    cla
                end
            else
                for k=1:nframes
                    plot(x{k},y{k},plotString)
                    title(['t=' num2str(t(k)) ' s'])
                    pause(.1)
                    cla
                end
            end
        end
        
        function plot_follicle_position_time_projection(obj, tid, varargin)
            %
            %   plot_follicle_position_time_projection(obj, tid, varargin)
            %
            % tid: trajectory ID.  Only a single ID is allowed.
            %
            % varargin{1}: Plot color/symbol string.
            %
            % varargin{2}: Optional 2 x 1 vector giving starting and ending times (in seconds) to include in
            %               returned image, inclusive, starting with 0.
            %               Of format: [startTimeInSec endTimeInSec]. Can be empty ([]) to allow
            %               access to varargin{3}.
            %
            %
            %
            if numel(tid) > 1
                error('Only a single trajectory ID is alowed.')
            end
            
            if nargin > 2
                plotString = varargin{1};
            else
                plotString = 'k-';
            end
            
            [y,x,t] = obj.get_cached_follicle_coords(tid);
            
            if nargin > 3
                restrictTime = varargin{2};
                if isempty(restrictTime)
                    restrictTime = [min(t) max(t)];
                elseif restrictTime(2) <= restrictTime(1)
                    error('Invalid format for varargin{2}.')
                elseif max(restrictTime) > max(t)
                    disp('Warning: varargin{2} exceeds max time; setting to max.')
                    restrictTime(restrictTime==max(restrictTime)) = max(t);
                    if restrictTime(1)==restrictTime(2)
                        error('varargin{2}: Both times exceed max time.')
                    end
                elseif min(restrictTime < 0)
                    disp('varargin{2}: times start at 0.')
                end
            else
                restrictTime = [min(t) max(t)];
            end
            
            frameInds = find(t >= restrictTime(1) & t <= restrictTime(2));
            hold on; axis ij
            plot(x(frameInds),y(frameInds),plotString)
            
        end
        
        
        
        
    end
    methods % Dependent property methods; cannot have attributes.
        
        function value = get.barPosClean(obj)
            % Bar position cleaned up by processing to handle bar tracker errors/limitations.
            
            if isempty(obj.barPos)
                value = [];
            else
                threshInMm = 2; % Values exceeding this distance (in mm) from the
                % modal position will be set to the mode.
                
                f = obj.barPos(:,1);
                x = round(obj.barPos(:,2));
                y = round(obj.barPos(:,3));
                ymode = mode(y);
                xmode = mode(x);
                
                ind = abs((y-ymode)/obj.pxPerMm) > threshInMm;
                
                % Replace outliers with mode. Note that this mode
                % has been rounded to the nearest pixel, whereas original
                % data in obj.barPos was sub-pixel resolution.
                y(ind) = ymode;
                x(ind) = xmode;
                
                value = [f x y];
            end
        end
        
    end
    
end

##### SOURCE END #####
--></body></html>